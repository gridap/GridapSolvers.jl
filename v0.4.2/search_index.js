var documenterSearchIndex = {"docs":
[{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"EditURL = \"../../../test/Applications/NavierStokesGMG.jl\"","category":"page"},{"location":"Examples/NavierStokesGMG/#Incompressible-Navier-Stokes-equations-in-a-2D/3D-cavity,-using-GMG.","page":"Navier-Stokes (GMG)","title":"Incompressible Navier-Stokes equations in a 2D/3D cavity, using GMG.","text":"","category":"section"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"This example solves the incompressible Stokes equations, given by","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"beginalign*\n-Delta u + textR_e (u nabla) u - nabla p = f quad textin quad Omega \nnabla cdot u = 0 quad textin quad Omega \nu = hatx quad textin quad Gamma_texttop subset partial Omega \nu = 0 quad textin quad partial Omega backslash Gamma_texttop \nendalign*","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"where Omega = 01^d.","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"We use a mixed finite-element scheme, with Q_k times P_k-1^- elements for the velocity-pressure pair.","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"To solve the linear system, we use a FGMRES solver preconditioned by a block-triangular Shur-complement-based preconditioner. We use an Augmented Lagrangian approach to get a better approximation of the Schur complement. Details for this preconditoner can be found in Benzi and Olshanskii (2006).","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"The velocity block is solved using a Geometric Multigrid (GMG) solver. Due to the kernel introduced by the Augmented-Lagrangian operator, we require special smoothers and prolongation/restriction operators. See Schoberl (1999) for more details.","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"module NavierStokesGMGApplication\n\nusing Test\nusing LinearAlgebra\nusing FillArrays, BlockArrays\n\nusing Gridap\nusing Gridap.ReferenceFEs, Gridap.Algebra, Gridap.Geometry, Gridap.FESpaces\nusing Gridap.CellData, Gridap.MultiField, Gridap.Algebra\nusing PartitionedArrays\nusing GridapDistributed\nusing GridapP4est\n\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers, GridapSolvers.MultilevelTools\nusing GridapSolvers.PatchBasedSmoothers, GridapSolvers.NonlinearSolvers\nusing GridapSolvers.BlockSolvers: NonlinearSystemBlock, LinearSystemBlock, BiformBlock, BlockTriangularSolver\n\nfunction get_patch_smoothers(mh,tests,biform,patch_decompositions,qdegree;is_nonlinear=false)\n  patch_spaces = PatchFESpace(tests,patch_decompositions)\n  nlevs = num_levels(mh)\n  smoothers = map(view(tests,1:nlevs-1),patch_decompositions,patch_spaces) do tests, PD, Ph\n    Vh = get_fe_space(tests)\n    Ω  = Triangulation(PD)\n    dΩ = Measure(Ω,qdegree)\n    ap = (u,du,dv) -> biform(u,du,dv,dΩ)\n    patch_smoother = PatchBasedLinearSolver(ap,Ph,Vh;is_nonlinear)\n    return RichardsonSmoother(patch_smoother,10,0.2)\n  end\n  return smoothers\nend\n\nfunction get_trilinear_form(mh_lev,triform,qdegree)\n  model = get_model(mh_lev)\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n  return (u,du,dv) -> triform(u,du,dv,dΩ)\nend\n\nfunction add_labels_2d!(labels)\n  add_tag_from_tags!(labels,\"top\",[6])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,7,8])\nend\n\nfunction add_labels_3d!(labels)\n  add_tag_from_tags!(labels,\"top\",[22])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26])\nend\n\nfunction main(distribute,np,nc,np_per_level)\n  parts = distribute(LinearIndices((prod(np),)))\n\n  Dc = length(nc)\n  domain = (Dc == 2) ? (0,1,0,1) : (0,1,0,1,0,1)\n  add_labels! = (Dc == 2) ? add_labels_2d! : add_labels_3d!\n  mh = CartesianModelHierarchy(parts,np_per_level,domain,nc;add_labels! = add_labels!)\n  model = get_model(mh,1)\n\n  order = 2\n  qdegree = 2*(order+1)\n  reffe_u = ReferenceFE(lagrangian,VectorValue{Dc,Float64},order)\n  reffe_p = ReferenceFE(lagrangian,Float64,order-1;space=:P)\n\n  u_walls = (Dc==2) ? VectorValue(0.0,0.0) : VectorValue(0.0,0.0,0.0)\n  u_top = (Dc==2) ? VectorValue(1.0,0.0) : VectorValue(1.0,0.0,0.0)\n\n  tests_u  = TestFESpace(mh,reffe_u,dirichlet_tags=[\"walls\",\"top\"]);\n  trials_u = TrialFESpace(tests_u,[u_walls,u_top]);\n  U, V = get_fe_space(trials_u,1), get_fe_space(tests_u,1)\n  Q = TestFESpace(model,reffe_p;conformity=:L2,constraint=:zeromean)\n\n  mfs = Gridap.MultiField.BlockMultiFieldStyle()\n  X = MultiFieldFESpace([U,Q];style=mfs)\n  Y = MultiFieldFESpace([V,Q];style=mfs)\n\n  Re = 10.0\n  ν = 1/Re\n  α = 1.e2\n  f = (Dc==2) ? VectorValue(1.0,1.0) : VectorValue(1.0,1.0,1.0)\n\n  Π_Qh = LocalProjectionMap(divergence,reffe_p,qdegree)\n  graddiv(u,v,dΩ) = ∫(α*(∇⋅v)⋅Π_Qh(u))dΩ\n\n  conv(u,∇u) = (∇u')⋅u\n  dconv(du,∇du,u,∇u) = conv(u,∇du)+conv(du,∇u)\n  c(u,v,dΩ) = ∫(v⊙(conv∘(u,∇(u))))dΩ\n  dc(u,du,dv,dΩ) = ∫(dv⊙(dconv∘(du,∇(du),u,∇(u))))dΩ\n\n  lap(u,v,dΩ) = ∫(ν*∇(v)⊙∇(u))dΩ\n  rhs(v,dΩ) = ∫(v⋅f)dΩ\n\n  jac_u(u,du,dv,dΩ) = lap(du,dv,dΩ) + dc(u,du,dv,dΩ) + graddiv(du,dv,dΩ)\n  jac((u,p),(du,dp),(dv,dq),dΩ) = jac_u(u,du,dv,dΩ) - ∫(divergence(dv)*dp)dΩ - ∫(divergence(du)*dq)dΩ\n\n  res_u(u,v,dΩ) = lap(u,v,dΩ) + c(u,v,dΩ) + graddiv(u,v,dΩ) - rhs(v,dΩ)\n  res((u,p),(v,q),dΩ) = res_u(u,v,dΩ) - ∫(divergence(v)*p)dΩ - ∫(divergence(u)*q)dΩ\n\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n  jac_h(x,dx,dy) = jac(x,dx,dy,dΩ)\n  res_h(x,dy) = res(x,dy,dΩ)\n  op = FEOperator(res_h,jac_h,X,Y)\n\n  biforms = map(mhl -> get_trilinear_form(mhl,jac_u,qdegree),mh)\n  patch_decompositions = PatchDecomposition(mh)\n  smoothers = get_patch_smoothers(\n    mh,trials_u,jac_u,patch_decompositions,qdegree;is_nonlinear=true\n  )\n  prolongations = setup_patch_prolongation_operators(\n    tests_u,jac_u,graddiv,qdegree;is_nonlinear=true\n  )\n  restrictions = setup_patch_restriction_operators(\n    tests_u,prolongations,graddiv,qdegree;solver=IS_ConjugateGradientSolver(;reltol=1.e-6)\n  )\n  gmg = GMGLinearSolver(\n    mh,trials_u,tests_u,biforms,\n    prolongations,restrictions,\n    pre_smoothers=smoothers,\n    post_smoothers=smoothers,\n    coarsest_solver=LUSolver(),\n    maxiter=2,mode=:preconditioner,verbose=i_am_main(parts),is_nonlinear=true\n  )\n\n  solver_u = gmg\n  solver_p = CGSolver(JacobiLinearSolver();maxiter=20,atol=1e-14,rtol=1.e-6,verbose=i_am_main(parts))\n  solver_u.log.depth = 3\n  solver_p.log.depth = 3\n\n  bblocks  = [NonlinearSystemBlock([1]) LinearSystemBlock();\n              LinearSystemBlock()       BiformBlock((p,q) -> ∫(-(1.0/α)*p*q)dΩ,Q,Q)]\n  coeffs = [1.0 1.0;\n            0.0 1.0]\n  P = BlockTriangularSolver(bblocks,[solver_u,solver_p],coeffs,:upper)\n  solver = FGMRESSolver(20,P;atol=1e-11,rtol=1.e-8,verbose=i_am_main(parts))\n  solver.log.depth = 2\n\n  nlsolver = NewtonSolver(solver;maxiter=20,atol=1e-10,rtol=1.e-12,verbose=i_am_main(parts))\n  xh = solve(nlsolver,op)\n\n  @test true\nend\n\nend # module","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"MultilevelTools/","page":"MultilevelTools","title":"MultilevelTools","text":"CurrentModule = GridapSolvers.MultilevelTools","category":"page"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools","text":"","category":"section"},{"location":"MultilevelTools/#Nested-subpartitions","page":"MultilevelTools","title":"Nested subpartitions","text":"","category":"section"},{"location":"MultilevelTools/","page":"MultilevelTools","title":"MultilevelTools","text":"One of the main difficulties of multilevel algorithms is dealing with the complexity of having multiple subcommunicators. We provide some tools to deal with it. In particular we introduce HierarchicalArrays.","category":"page"},{"location":"MultilevelTools/","page":"MultilevelTools","title":"MultilevelTools","text":"generate_level_parts\nHierarchicalArray\nBase.map\nwith_level","category":"page"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.generate_level_parts","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.generate_level_parts","text":"generate_level_parts(root_parts::AbstractArray,num_procs_x_level::Vector{<:Integer})\n\nFrom a root communicator root_parts, generate a sequence of nested    subcommunicators with sizes given by num_procs_x_level.\n\n\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.HierarchicalArray","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.HierarchicalArray","text":"HierarchicalArray{T,A,B} <: AbstractVector{T}\n\nArray of hierarchical (nested) distributed objects.   Each level might live in a different subcommunicator. If a processor does not belong to    subcommunicator ranks[i], then array[i] is nothing.\n\nHowever, it assumes:      - The subcommunicators are nested, so that ranks[i] contains ranks[i+1].     - The first subcommunicator does not have empty parts.\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#Base.map","page":"MultilevelTools","title":"Base.map","text":"Base.map(f::Function,args::Vararg{HierarchicalArray,N}) where N\n\nMaps a function to a set of HierarchicalArrays. The function is applied only in the   subcommunicators where the processor belongs to.\n\n\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.with_level","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.with_level","text":"with_level(f::Function,a::HierarchicalArray,lev::Integer;default=nothing)\n\nApplies a function to the lev-th level of a HierarchicalArray. If the processor does not   belong to the subcommunicator of the lev-th level, then default is returned.\n\n\n\n\n\n","category":"function"},{"location":"MultilevelTools/#ModelHierarchies-and-FESpaceHierarchies","page":"MultilevelTools","title":"ModelHierarchies and FESpaceHierarchies","text":"","category":"section"},{"location":"MultilevelTools/","page":"MultilevelTools","title":"MultilevelTools","text":"This objects are the multilevel counterparts of Gridap's DiscreteModel and FESpace.","category":"page"},{"location":"MultilevelTools/","page":"MultilevelTools","title":"MultilevelTools","text":"ModelHierarchy\nModelHierarchyLevel\nCartesianModelHierarchy\nP4estCartesianModelHierarchy\nFESpaceHierarchy","category":"page"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.ModelHierarchy","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.ModelHierarchy","text":"const ModelHierarchy = HierarchicalArray{<:ModelHierarchyLevel}\n\nA ModelHierarchy is a hierarchical array of ModelHierarchyLevel objects. It stores the    adapted/redistributed models and the corresponding subcommunicators.\n\nFor convenience, implements some of the API of DiscreteModel.\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.ModelHierarchyLevel","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.ModelHierarchyLevel","text":"Single level for a ModelHierarchy.\n\nNote that model_red and red_glue might be of type Nothing   whenever there is no redistribution in a given level.\n\nref_glue is of type Nothing on the coarsest level.\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.CartesianModelHierarchy","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.CartesianModelHierarchy","text":"CartesianModelHierarchy(\n  ranks::AbstractVector{<:Integer},\n  np_per_level::Vector{<:NTuple{D,<:Integer}},\n  domain::Tuple,\n  nc::NTuple{D,<:Integer};\n  nrefs::Union{<:Integer,Vector{<:Integer},Vector{<:NTuple{D,<:Integer}},NTuple{D,<:Integer}},\n  map::Function = identity,\n  isperiodic::NTuple{D,Bool} = Tuple(fill(false,D)),\n  add_labels!::Function = (labels -> nothing),\n) where D\n\nReturns a ModelHierarchy with a Cartesian model as coarsest level. The i-th level    will be distributed among np_per_level[i] processors. Two consecutive levels are    refined by a factor of nrefs[i].\n\nParameters:\n\nranks: Initial communicator. Will be used to generate subcommunicators.\ndomain: Tuple containing the domain limits.\nnc: Tuple containing the number of cells in each direction for the coarsest model.\nnp_per_level: Vector containing the number of processors we want to distribute each level into. Requires a tuple np = (np_1,...,np_d) for each level, then each  level will be distributed among prod(np) processors with np_i processors in the i-th direction.\nnrefs: Vector containing the refinement factor for each level. Has nlevs-1 entries,    and each entry can either be an integer (homogeneous refinement) or a tuple    with D integers (inhomogeneous refinement).\n\n\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.P4estCartesianModelHierarchy","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.P4estCartesianModelHierarchy","text":"P4estCartesianModelHierarchy(\n  ranks,np_per_level,domain,nc::NTuple{D,<:Integer};\n  num_refs_coarse::Integer = 0,\n  add_labels!::Function = (labels -> nothing),\n  map::Function = identity,\n  isperiodic::NTuple{D,Bool} = Tuple(fill(false,D))\n) where D\n\nReturns a ModelHierarchy with a Cartesian model as coarsest level, using GridapP4est.jl.    The i-th level will be distributed among np_per_level[i] processors.    The seed model is given by cmodel = CartesianDiscreteModel(domain,nc).\n\n\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.FESpaceHierarchy","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.FESpaceHierarchy","text":"const FESpaceHierarchy = HierarchicalArray{<:FESpaceHierarchyLevel}\n\nA FESpaceHierarchy is a hierarchical array of FESpaceHierarchyLevel objects. It stores the    adapted/redistributed fe spaces and the corresponding subcommunicators.\n\nFor convenience, implements some of the API of FESpace.\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#Grid-transfer-operators","page":"MultilevelTools","title":"Grid transfer operators","text":"","category":"section"},{"location":"MultilevelTools/","page":"MultilevelTools","title":"MultilevelTools","text":"To move information between different levels, we will require grid transfer operators. Although any custom-made operator can be used, we provide some options.","category":"page"},{"location":"MultilevelTools/","page":"MultilevelTools","title":"MultilevelTools","text":"DistributedGridTransferOperator\nRestrictionOperator\nProlongationOperator\nMultiFieldTransferOperator","category":"page"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.DistributedGridTransferOperator","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.DistributedGridTransferOperator","text":"\n\n\n\n","category":"type"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.RestrictionOperator","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.RestrictionOperator","text":"\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.ProlongationOperator","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.ProlongationOperator","text":"\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.MultiFieldTransferOperator","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.MultiFieldTransferOperator","text":"\n\n\n\n","category":"type"},{"location":"MultilevelTools/#Local-projection-maps","page":"MultilevelTools","title":"Local projection maps","text":"","category":"section"},{"location":"MultilevelTools/","page":"MultilevelTools","title":"MultilevelTools","text":"LocalProjectionMap\nReffeProjectionMap\nSpaceProjectionMap","category":"page"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.LocalProjectionMap","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.LocalProjectionMap","text":"abstract type LocalProjectionMap{T} <: Map end\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.ReffeProjectionMap","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.ReffeProjectionMap","text":"struct ReffeProjectionMap{T} <: LocalProjectionMap{T}\n  op      :: Operation{T}\n  reffe   :: Tuple{<:ReferenceFEName,Any,Any}\n  qdegree :: Int\nend\n\nMap that projects a field/field-basis onto another local reference space  given by a ReferenceFE.\n\nExample:\n\nmodel = CartesianDiscreteModel((0,1,0,1),(2,2))\n\nreffe_h1 = ReferenceFE(QUAD,lagrangian,Float64,1,space=:Q)\nreffe_l2 = ReferenceFE(QUAD,lagrangian,Float64,1,space=:P)\nU = FESpace(model,reffe_h1)\nu_h1 = interpolate(f,U)\n\nΩ = Triangulation(model)\ndΩ = Measure(Ω,2)\n\nΠ = LocalProjectionMap(reffe_l2)\nu_l2 = Π(u_h1,dΩ)\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.SpaceProjectionMap","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.SpaceProjectionMap","text":"struct SpaceProjectionMap{T} <: LocalProjectionMap{T}\n  op      :: Operation{T}\n  space   :: A\n  qdegree :: Int\nend\n\nMap that projects a CellField onto another FESpace. Necessary when the arrival space  has constraints (e.g. boundary conditions) that need to be taken into account.\n\n\n\n\n\n","category":"type"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"EditURL = \"../../../test/Applications/NavierStokes.jl\"","category":"page"},{"location":"Examples/NavierStokes/#Incompressible-Navier-Stokes-equations-in-a-2D/3D-cavity","page":"Navier-Stokes","title":"Incompressible Navier-Stokes equations in a 2D/3D cavity","text":"","category":"section"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"This example solves the incompressible Stokes equations, given by","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"beginalign*\n-Delta u + textR_e (u nabla) u - nabla p = f quad textin quad Omega \nnabla cdot u = 0 quad textin quad Omega \nu = hatx quad textin quad Gamma_texttop subset partial Omega \nu = 0 quad textin quad partial Omega backslash Gamma_texttop \nendalign*","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"where Omega = 01^d.","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"We use a mixed finite-element scheme, with Q_k times P_k-1^- elements for the velocity-pressure pair.","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"To solve the linear system, we use a FGMRES solver preconditioned by a block-triangular Shur-complement-based preconditioner. We use an Augmented Lagrangian approach to get a better approximation of the Schur complement. Details for this preconditoner can be found in Benzi and Olshanskii (2006).","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"The velocity block is solved directly using an exact solver.","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"module NavierStokesApplication\n\nusing Test\nusing LinearAlgebra\nusing FillArrays, BlockArrays\n\nusing Gridap\nusing Gridap.ReferenceFEs, Gridap.Algebra, Gridap.Geometry, Gridap.FESpaces\nusing Gridap.CellData, Gridap.MultiField, Gridap.Algebra\nusing PartitionedArrays\nusing GridapDistributed\n\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers, GridapSolvers.MultilevelTools, GridapSolvers.NonlinearSolvers\nusing GridapSolvers.BlockSolvers: LinearSystemBlock, NonlinearSystemBlock, BiformBlock, BlockTriangularSolver\n\nfunction add_labels_2d!(labels)\n  add_tag_from_tags!(labels,\"top\",[6])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,7,8])\nend\n\nfunction add_labels_3d!(labels)\n  add_tag_from_tags!(labels,\"top\",[22])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26])\nend\n\nfunction main(distribute,np,nc)\n  parts = distribute(LinearIndices((prod(np),)))\n\n  Dc = length(nc)\n  domain = (Dc == 2) ? (0,1,0,1) : (0,1,0,1,0,1)\n  model = CartesianDiscreteModel(parts,np,domain,nc)\n  add_labels! = (Dc == 2) ? add_labels_2d! : add_labels_3d!\n  add_labels!(get_face_labeling(model))\n\n  order = 2\n  qdegree = 2*(order+1)\n  reffe_u = ReferenceFE(lagrangian,VectorValue{Dc,Float64},order)\n  reffe_p = ReferenceFE(lagrangian,Float64,order-1;space=:P)\n\n  u_walls = (Dc==2) ? VectorValue(0.0,0.0) : VectorValue(0.0,0.0,0.0)\n  u_top = (Dc==2) ? VectorValue(1.0,0.0) : VectorValue(1.0,0.0,0.0)\n\n  V = TestFESpace(model,reffe_u,dirichlet_tags=[\"walls\",\"top\"]);\n  U = TrialFESpace(V,[u_walls,u_top]);\n  Q = TestFESpace(model,reffe_p;conformity=:L2,constraint=:zeromean)\n\n  mfs = Gridap.MultiField.BlockMultiFieldStyle()\n  X = MultiFieldFESpace([U,Q];style=mfs)\n  Y = MultiFieldFESpace([V,Q];style=mfs)\n\n  Re = 10.0\n  ν = 1/Re\n  α = 1.e2\n  f = (Dc==2) ? VectorValue(0.0,0.0) : VectorValue(0.0,0.0,0.0)\n\n  Π_Qh = LocalProjectionMap(divergence,Q,qdegree)\n  graddiv(u,v,dΩ) = ∫(α*(∇⋅v)⋅Π_Qh(u))dΩ\n\n  conv(u,∇u) = (∇u')⋅u\n  dconv(du,∇du,u,∇u) = conv(u,∇du)+conv(du,∇u)\n  c(u,v,dΩ) = ∫(v⊙(conv∘(u,∇(u))))dΩ\n  dc(u,du,dv,dΩ) = ∫(dv⊙(dconv∘(du,∇(du),u,∇(u))))dΩ\n\n  lap(u,v,dΩ) = ∫(ν*∇(v)⊙∇(u))dΩ\n  rhs(v,dΩ) = ∫(v⋅f)dΩ\n\n  jac_u(u,du,dv,dΩ) = lap(du,dv,dΩ) + dc(u,du,dv,dΩ) + graddiv(du,dv,dΩ)\n  jac((u,p),(du,dp),(dv,dq),dΩ) = jac_u(u,du,dv,dΩ) - ∫(divergence(dv)*dp)dΩ - ∫(divergence(du)*dq)dΩ\n\n  res_u(u,v,dΩ) = lap(u,v,dΩ) + c(u,v,dΩ) + graddiv(u,v,dΩ) - rhs(v,dΩ)\n  res((u,p),(v,q),dΩ) = res_u(u,v,dΩ) - ∫(divergence(v)*p)dΩ - ∫(divergence(u)*q)dΩ\n\n  Ω  = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n  jac_h(x,dx,dy) = jac(x,dx,dy,dΩ)\n  res_h(x,dy) = res(x,dy,dΩ)\n  op = FEOperator(res_h,jac_h,X,Y)\n\n  solver_u = LUSolver()\n  solver_p = CGSolver(JacobiLinearSolver();maxiter=20,atol=1e-14,rtol=1.e-6,verbose=i_am_main(parts))\n  solver_p.log.depth = 4\n\n  bblocks  = [NonlinearSystemBlock() LinearSystemBlock();\n              LinearSystemBlock()    BiformBlock((p,q) -> ∫(-(1.0/α)*p*q)dΩ,Q,Q)]\n  coeffs = [1.0 1.0;\n            0.0 1.0]\n  P = BlockTriangularSolver(bblocks,[solver_u,solver_p],coeffs,:upper)\n  solver = FGMRESSolver(20,P;atol=1e-11,rtol=1.e-8,verbose=i_am_main(parts))\n  solver.log.depth = 2\n\n  nlsolver = NewtonSolver(solver;maxiter=20,atol=1e-10,rtol=1.e-12,verbose=i_am_main(parts))\n  xh = solve(nlsolver,op);\n\n  @test true\nend\n\nend # module","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"SolverInterfaces/","page":"SolverInterfaces","title":"SolverInterfaces","text":"CurrentModule = GridapSolvers.SolverInterfaces","category":"page"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces","text":"","category":"section"},{"location":"SolverInterfaces/#SolverTolerances","page":"SolverInterfaces","title":"SolverTolerances","text":"","category":"section"},{"location":"SolverInterfaces/","page":"SolverInterfaces","title":"SolverInterfaces","text":"  SolverTolerances\n  SolverConvergenceFlag\n  get_solver_tolerances\n  set_solver_tolerances!\n  finished\n  converged\n  finished_flag","category":"page"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.SolverTolerances","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.SolverTolerances","text":"mutable struct SolverTolerances{T}\n  ...\nend\n\nSolverTolerances{T}(\n  maxiter :: Int = 1000,\n  atol    :: T   = eps(T),\n  rtol    :: T   = 1.e-5,\n  dtol    :: T   = Inf\n)\n\nStructure to check convergence conditions for iterative linear solvers.\n\nMethods:\n\nget_solver_tolerances\nset_solver_tolerances!\nconverged\nfinished\nfinished_flag\n\n\n\n\n\n","category":"type"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.SolverConvergenceFlag","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.SolverConvergenceFlag","text":"@enum SolverConvergenceFlag begin\n  SOLVER_CONVERGED_ATOL     = 0\n  SOLVER_CONVERGED_RTOL     = 1\n  SOLVER_DIVERGED_MAXITER   = 2\n  SOLVER_DIVERGED_BREAKDOWN = 3\nend\n\nConvergence flags for iterative linear solvers.\n\n\n\n\n\n","category":"type"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.get_solver_tolerances","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.get_solver_tolerances","text":"get_solver_tolerances(s::LinearSolver)\n\nReturns the solver tolerances of the linear solver s.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.set_solver_tolerances!","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.set_solver_tolerances!","text":"set_solver_tolerances!(s::LinearSolver;\n  maxiter = 1000,\n  atol   = eps(T),\n  rtol   = T(1.e-5),\n  dtol   = T(Inf)\n)\n\nModifies tolerances of the linear solver s.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.finished","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.finished","text":"finished(tols::SolverTolerances,niter,e_a,e_r) :: Bool\n\nReturns true if the solver has finished, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.converged","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.converged","text":"converged(tols::SolverTolerances,niter,e_a,e_r) :: Bool\n\nReturns true if the solver has converged, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.finished_flag","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.finished_flag","text":"finished_flag(tols::SolverTolerances,niter,e_a,e_r) :: SolverConvergenceFlag\n\nComputes the solver exit condition given \n\nthe number of iterations niter\nthe absolute error e_a \nand the relative error e_r.\n\nReturns the corresponding SolverConvergenceFlag.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#ConvergenceLogs","page":"SolverInterfaces","title":"ConvergenceLogs","text":"","category":"section"},{"location":"SolverInterfaces/","page":"SolverInterfaces","title":"SolverInterfaces","text":"  ConvergenceLog\n  SolverVerboseLevel\n  reset!\n  init!\n  update!\n  finalize!\n  print_message","category":"page"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.ConvergenceLog","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.ConvergenceLog","text":"mutable struct ConvergenceLog{T}\n  ...\nend\n\nConvergenceLog(\n  name :: String,\n  tols :: SolverTolerances{T};\n  verbose = SOLVER_VERBOSE_NONE,\n  depth   = 0\n)\n\nStandarized logging system for iterative linear solvers.\n\nMethods:\n\nreset!\ninit!\nupdate!\nfinalize!\nprint_message\n\n\n\n\n\n","category":"type"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.SolverVerboseLevel","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.SolverVerboseLevel","text":"@enum SolverVerboseLevel begin\n  SOLVER_VERBOSE_NONE = 0\n  SOLVER_VERBOSE_LOW  = 1\n  SOLVER_VERBOSE_HIGH = 2\nend\n\nSolverVerboseLevel(true) = SOLVER_VERBOSE_HIGH\nSolverVerboseLevel(false) = SOLVER_VERBOSE_NONE\n\n\n\n\n\n","category":"type"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.reset!","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.reset!","text":"reset!(log::ConvergenceLog{T})\n\nResets the convergence log log to its initial state.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.init!","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.init!","text":"init!(log::ConvergenceLog{T},r0::T)\n\nInitializes the convergence log log with the initial residual r0.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.update!","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.update!","text":"update!(log::ConvergenceLog{T},r::T)\n\nUpdates the convergence log log with the residual r at the current iteration.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.finalize!","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.finalize!","text":"finalize!(log::ConvergenceLog{T},r::T)\n\nFinalizes the convergence log log with the final residual r.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.print_message","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.print_message","text":"print_message(log::ConvergenceLog{T},msg::String)\n\nPrints the message msg to the output stream of the convergence log log.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"CurrentModule = GridapSolvers.BlockSolvers","category":"page"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers","text":"","category":"section"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"Many scalable preconditioners for multiphysics problems are based on (possibly partial) block factorizations. This module provides a simple interface to define and use block solvers for block-assembled systems.","category":"page"},{"location":"BlockSolvers/#Block-types","page":"BlockSolvers","title":"Block types","text":"","category":"section"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"In a same preconditioner, blocks can come from different sources. For example, in a Schur-complement-based preconditioner you might want to solve the eliminated block (which comes from the original matrix), while having an approximation for your Schur complement (which can come from a matrix assembled in your driver, or from a weakform).","category":"page"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"For this reason, we define the following abstract interface:","category":"page"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"  SolverBlock\n  LinearSolverBlock\n  NonlinearSolverBlock","category":"page"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.SolverBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.SolverBlock","text":"abstract type SolverBlock end\n\nAbstract type representing a block in a block solver. More specifically, it    indicates how a block is obtained from the original system matrix.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.LinearSolverBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.LinearSolverBlock","text":"abstract type LinearSolverBlock <: SolverBlock end\n\nSolverBlock that will not be updated between nonlinear iterations.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.NonlinearSolverBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.NonlinearSolverBlock","text":"abstract type NonlinearSolverBlock <: SolverBlock end\n\nSolverBlock that will be updated between nonlinear iterations.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"On top of this interface, we provide some useful block implementations:","category":"page"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"  LinearSystemBlock\n  NonlinearSystemBlock\n  MatrixBlock\n  BiformBlock\n  TriformBlock","category":"page"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.LinearSystemBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.LinearSystemBlock","text":"struct LinearSystemBlock <: LinearSolverBlock\n\nSolverBlock representing a linear (i.e non-updateable) block that is directly    taken from the system matrix. This block will not be updated between nonlinear    iterations.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.NonlinearSystemBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.NonlinearSystemBlock","text":"struct NonlinearSystemBlock <: LinearSolverBlock\n  I :: Vector{Int}\nend\n\nSolverBlock representing a nonlinear (i.e updateable) block that is directly    taken from the system matrix. This block will be updated between nonlinear   iterations.\n\nParameters:\n\n- `ids::Vector{Int8}`: Block indices considered when updating the nonlinear block. \n   By default, all indices are considered.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.MatrixBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.MatrixBlock","text":"struct MatrixBlock{A} <: LinearSolverBlock\n\nSolverBlock representing an external, independent matrix. \n\nParameters:\n\nmat::A: The matrix.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BiformBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BiformBlock","text":"struct BiformBlock <: LinearSolverBlock\n\nSolverBlock representing a linear block assembled from a bilinear form.    This block will be not updated between nonlinear iterations.\n\nParameters:\n\nf::Function: The bilinear form, i.e f(du,dv) = ∫(...)dΩ\ntrial::FESpace: The trial space.\ntest::FESpace: The test space.\nassem::Assembler: The assembler to use.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.TriformBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.TriformBlock","text":"struct TriformBlock <: NonlinearSolverBlock\n\nSolverBlock representing a nonlinear block assembled from a trilinear form.    This block will be updated between nonlinear iterations.\n\nParameters:\n\nf::Function: The trilinear form, i.e f(u,du,dv) = ∫(...)dΩ\nparam::FESpace: The parameter space, where u lives.\ntrial::FESpace: The trial space, where du lives.\ntest::FESpace: The test space, where dv lives.\nassem::Assembler: The assembler to use.\nids::Vector{Int8}: Block indices considered when updating the nonlinear block.    By default, all indices are considered.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"To create a new type of block, one needs to implement the following implementation (similar to the one for LinearSolver):","category":"page"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"  block_symbolic_setup\n  block_numerical_setup\n  block_numerical_setup!\n  block_offdiagonal_setup\n  block_offdiagonal_setup!","category":"page"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.block_symbolic_setup","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.block_symbolic_setup","text":"block_symbolic_setup(block::SolverBlock,solver::LinearSolver,mat::AbstractMatrix)\nblock_symbolic_setup(block::SolverBlock,solver::LinearSolver,mat::AbstractMatrix,x::AbstractVector)\n\nGiven a SolverBlock, returns the symbolic setup associated to the LinearSolver.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.block_numerical_setup","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.block_numerical_setup","text":"block_numerical_setup(block::SolverBlock,ss::BlockSS,mat::AbstractMatrix)\nblock_numerical_setup(block::SolverBlock,ss::BlockSS,mat::AbstractMatrix,x::AbstractVector)\n\nGiven a SolverBlock, returns the numerical setup associated to it.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.block_numerical_setup!","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.block_numerical_setup!","text":"block_numerical_setup!(block::SolverBlock,ns::BlockNS,mat::AbstractMatrix)\nblock_numerical_setup!(block::SolverBlock,ns::BlockNS,mat::AbstractMatrix,x::AbstractVector)\n\nGiven a SolverBlock, updates the numerical setup associated to it.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.block_offdiagonal_setup","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.block_offdiagonal_setup","text":"block_offdiagonal_setup(block::SolverBlock,mat::AbstractMatrix)\nblock_offdiagonal_setup(block::SolverBlock,mat::AbstractMatrix,x::AbstractVector)\n\nGiven a SolverBlock, returns the off-diagonal block of associated to it.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.block_offdiagonal_setup!","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.block_offdiagonal_setup!","text":"block_offdiagonal_setup!(cache,block::SolverBlock,mat::AbstractMatrix)\nblock_offdiagonal_setup!(cache,block::SolverBlock,mat::AbstractMatrix,x::AbstractVector)\n\nGiven a SolverBlock, updates the off-diagonal block of associated to it.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/#Block-solvers","page":"BlockSolvers","title":"Block solvers","text":"","category":"section"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"We can combine blocks to define a block solver. All block solvers take an array of blocks and a vector of solvers for the diagonal blocks (which need to be solved for). We provide two common types of block solvers:","category":"page"},{"location":"BlockSolvers/#BlockDiagonalSolvers","page":"BlockSolvers","title":"BlockDiagonalSolvers","text":"","category":"section"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"  BlockDiagonalSolver\n  BlockDiagonalSolver(blocks::AbstractVector{<:SolverBlock},solvers::AbstractVector{<:LinearSolver})\n  BlockDiagonalSolver(solvers::AbstractVector{<:LinearSolver})\n  BlockDiagonalSolver(funcs::AbstractArray{<:Function},trials::AbstractArray{<:FESpace},tests::AbstractArray{<:FESpace},solvers::AbstractArray{<:LinearSolver})","category":"page"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockDiagonalSolver","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockDiagonalSolver","text":"struct BlockDiagonalSolver{N} <: LinearSolver\n\nSolver representing a block-diagonal solver, i.e \n\n│ A11   0    0  │   │ x1 │   │ r1 │\n│  0   A22   0  │ ⋅ │ x2 │ = │ r2 │\n│  0    0   A33 │   │ x3 │   │ r3 │\n\nwhere N is the number of diagonal blocks.\n\nProperties:\n\nblocks::AbstractVector{<:SolverBlock}: Matrix of solver blocks, indicating how    each diagonal block of the preconditioner is obtained. \nsolvers::AbstractVector{<:LinearSolver}: Vector of solvers,    one for each diagonal block.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockDiagonalSolver-Tuple{AbstractVector{<:GridapSolvers.BlockSolvers.SolverBlock}, AbstractVector{<:Gridap.Algebra.LinearSolver}}","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockDiagonalSolver","text":"function BlockDiagonalSolver(\n  blocks  :: AbstractVector{<:SolverBlock},\n  solvers :: AbstractVector{<:LinearSolver}\n)\n\nCreate and instance of BlockDiagonalSolver from its underlying properties.\n\n\n\n\n\n","category":"method"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockDiagonalSolver-Tuple{AbstractVector{<:Gridap.Algebra.LinearSolver}}","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockDiagonalSolver","text":"function BlockDiagonalSolver(\n  solvers::AbstractVector{<:LinearSolver}; \n  is_nonlinear::Vector{Bool}=fill(false,length(solvers))\n)\n\nCreate and instance of BlockDiagonalSolver where all blocks are extracted from  the linear system.\n\n\n\n\n\n","category":"method"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockDiagonalSolver-Tuple{AbstractArray{<:Function}, AbstractArray{<:Gridap.FESpaces.FESpace}, AbstractArray{<:Gridap.FESpaces.FESpace}, AbstractArray{<:Gridap.Algebra.LinearSolver}}","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockDiagonalSolver","text":"function BlockDiagonalSolver(\n  funcs   :: AbstractArray{<:Function},\n  trials  :: AbstractArray{<:FESpace},\n  tests   :: AbstractArray{<:FESpace},\n  solvers :: AbstractArray{<:LinearSolver};\n  is_nonlinear::Vector{Bool}=fill(false,length(solvers))\n)\n\nCreate and instance of BlockDiagonalSolver where all blocks are given by  integral forms.\n\n\n\n\n\n","category":"method"},{"location":"BlockSolvers/#BlockTriangularSolvers","page":"BlockSolvers","title":"BlockTriangularSolvers","text":"","category":"section"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"BlockTriangularSolver\nBlockTriangularSolver(blocks::AbstractMatrix{<:SolverBlock},solvers ::AbstractVector{<:LinearSolver},)\nBlockTriangularSolver(solvers::AbstractVector{<:LinearSolver})","category":"page"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockTriangularSolver","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockTriangularSolver","text":"struct BlockTriangularSolver{T,N} <: LinearSolver\n\nSolver representing a block-triangular (upper/lower) solver, i.e \n\n│ A11  c12⋅A12  c13⋅A13 │   │ x1 │   │ r1 │\n│  0       A22  c23⋅A23 │ ⋅ │ x2 │ = │ r2 │\n│  0      0         A33 │   │ x3 │   │ r3 │\n\nwhere N is the number of diagonal blocks and T is either Val{:upper} or Val{:lower}.\n\nProperties:\n\nblocks::AbstractMatrix{<:SolverBlock}: Matrix of solver blocks, indicating how    each block of the preconditioner is obtained. \nsolvers::AbstractVector{<:LinearSolver}: Vector of solvers,    one for each diagonal block.\ncoeffs::AbstractMatrix{<:Real}: Matrix of coefficients, indicating the    contribution of the off-diagonal blocks to the right-hand side of each    diagonal. In particular, blocks can be turned off by setting the corresponding    coefficient to zero.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockTriangularSolver-Tuple{AbstractMatrix{<:GridapSolvers.BlockSolvers.SolverBlock}, AbstractVector{<:Gridap.Algebra.LinearSolver}}","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockTriangularSolver","text":"function BlockTriangularSolver(\n  blocks  :: AbstractMatrix{<:SolverBlock},\n  solvers :: AbstractVector{<:LinearSolver},\n  coeffs = fill(1.0,size(blocks)),\n  half   = :upper\n)\n\nCreate and instance of BlockTriangularSolver from its underlying properties. The kwarg half can have values :upper or :lower.\n\n\n\n\n\n","category":"method"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockTriangularSolver-Tuple{AbstractVector{<:Gridap.Algebra.LinearSolver}}","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockTriangularSolver","text":"function BlockTriangularSolver(\n  solvers::AbstractVector{<:LinearSolver}; \n  is_nonlinear::Matrix{Bool}=fill(false,(length(solvers),length(solvers))),\n  coeffs=fill(1.0,size(is_nonlinear)),\n  half=:upper\n)\n\nCreate and instance of BlockTriangularSolver where all blocks are extracted from  the linear system. The kwarg half can have values :upper or :lower.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/","page":"PatchBasedSmoothers","title":"PatchBasedSmoothers","text":"CurrentModule = GridapSolvers.PatchBasedSmoothers","category":"page"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers","text":"","category":"section"},{"location":"PatchBasedSmoothers/","page":"PatchBasedSmoothers","title":"PatchBasedSmoothers","text":"Modules = [PatchBasedSmoothers,]","category":"page"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchBasedLinearSolver","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchBasedLinearSolver","text":"struct PatchBasedLinearSolver <: LinearSolver\n  ...\nend\n\nSub-assembled linear solver for patch-based methods. Given a bilinear form a and a space decomposition V = Σ_i V_i given by a patch space, returns a global correction given by aggregated local corrections, i.e \n\ndx = Σ_i w_i I_i inv(A_i) (I_i)^* x \n\nwhere A_i is the patch-local system matrix defined by \n\n(A_i u_i, v_i) = a(u_i,v_i) ∀ v_i ∈ V_i\n\nand I_i is the natural injection from the patch space to the global space. The aggregation can be un-weighted (i.e. w_i = 1) or weighted, where w_i = 1/#(i).\n\n\n\n\n\n","category":"type"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchBasedLinearSolver-Tuple{Function, Gridap.FESpaces.FESpace, Gridap.FESpaces.FESpace}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchBasedLinearSolver","text":"function PatchBasedLinearSolver(\n  biform::Function, \n  patch_space::FESpace, \n  space::FESpace;\n  local_solver = LUSolver(),\n  is_nonlinear = false,\n  weighted = false\n)\n\nReturns an instance of PatchBasedLinearSolver from its underlying properties.   Local patch-systems are solved with local_solver. If weighted, uses weighted    patch aggregation to compute the global correction.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchBoundaryStyle","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchBoundaryStyle","text":"abstract type PatchBoundaryStyle end\nstruct PatchBoundaryExclude  <: PatchBoundaryStyle end\nstruct PatchBoundaryInclude  <: PatchBoundaryStyle end\n\nControls the boundary consitions imposed at the patch boundaries for the sub-spaces.\n\nPatchBoundaryInclude: No BCs are imposed at the patch boundaries. \nPatchBoundaryExclude: Zero dirichlet BCs are imposed at the patch boundaries.\n\n\n\n\n\n","category":"type"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchDecomposition","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchDecomposition","text":"struct PatchDecomposition{Dr,Dc,Dp} <: DiscreteModel{Dc,Dp}\n\nRepresents a patch decomposition of a discrete model, i.e an overlapping cell covering {Ω_i} of Ω such that Ω = Σ_i Ω_i.\n\nProperties:\n\nDr::Integer : Dimension of the patch root\nmodel::DiscreteModel{Dc,Dp} : Underlying discrete model\npatch_cells::Table : [patch][local cell] -> cell\npatch_cells_overlapped::Table        : [patch][local cell] -> overlapped cell\npatch_cells_faces_on_boundary::Table : [d][overlapped cell][local face] -> face is on patch boundary\n\n\n\n\n\n","category":"type"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchDecomposition-Union{Tuple{Gridap.Geometry.DiscreteModel{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchDecomposition","text":"function PatchDecomposition(\n  model::DiscreteModel{Dc,Dp};\n  Dr=0,\n  patch_boundary_style::PatchBoundaryStyle=PatchBoundaryExclude(),\n  boundary_tag_names::AbstractArray{String}=[\"boundary\"]\n)\n\nReturns an instance of PatchDecomposition from a given discrete model.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchFESpace","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchFESpace","text":"struct PatchFESpace <: SingleFieldFESpace\n  ...\nend\n\nFESpace representing a patch-based subspace decomposition V = Σ_i V_i of a global space V.\n\n\n\n\n\n","category":"type"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace, PatchDecomposition, Gridap.FESpaces.CellConformity}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchFESpace","text":"function PatchFESpace(\n  space::FESpaces.SingleFieldFESpace,\n  patch_decomposition::PatchDecomposition,\n  cell_conformity::CellConformity;\n  patches_mask=Fill(false,num_patches(patch_decomposition))\n)\n\nConstructs a PatchFESpace from a global SingleFieldFESpace, a PatchDecomposition and a CellConformity instance.\n\nIf patches_mask[p] = true, the patch p is ignored. Used in parallel.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace, PatchDecomposition, Union{Tuple{Gridap.ReferenceFEs.ReferenceFEName, Any, Any}, Gridap.ReferenceFEs.ReferenceFE}}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchFESpace","text":"function PatchFESpace(\n  space::FESpaces.SingleFieldFESpace,\n  patch_decomposition::PatchDecomposition,\n  reffe::Union{ReferenceFE,Tuple{<:ReferenceFEs.ReferenceFEName,Any,Any}};\n  conformity=nothing,\n  patches_mask=Fill(false,num_patches(patch_decomposition))\n)\n\nConstructs a PatchFESpace from a global SingleFieldFESpace and a PatchDecomposition. The conformity of the FESpace is deduced from reffe and conformity, which need to be  the same as the ones used to construct the global FESpace.\n\nIf patches_mask[p] = true, the patch p is ignored. Used in parallel.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchFESpace-Tuple{Gridap.MultiField.MultiFieldFESpace, PatchDecomposition, Vector{<:Gridap.FESpaces.CellConformity}}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchFESpace","text":"function PatchFESpace(\n  space::Gridap.MultiField.MultiFieldFESpace,\n  patch_decomposition::PatchDecomposition,\n  cell_conformity::Vector{<:CellConformity};\n  kwargs...\n)\n\nPatchFESpace constructor for MultiFieldFESpace.  Returns a MultiFieldFESpace of PatchFESpaces .\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchProlongationOperator","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchProlongationOperator","text":"struct PatchProlongationOperator end\n\nA PatchProlongationOperator is a modified prolongation operator such that given a coarse solution xH returns \n\nxh = Ih(xH) - yh\n\nwhere yh is a subspace-based correction computed by solving local problems on coarse cells  within the fine mesh.\n\n\n\n\n\n","category":"type"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchProlongationOperator-NTuple{5, Any}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchProlongationOperator","text":"function PatchProlongationOperator(\n  lev :: Integer,\n  sh  :: FESpaceHierarchy,\n  PD  :: PatchDecomposition,\n  lhs :: Function,\n  rhs :: Function;\n  is_nonlinear=false\n)\n\nReturns an instance of PatchProlongationOperator for a given level lev and a given  FESpaceHierarchy sh. The subspace-based correction on a solution uH is computed  by solving local problems given by \n\n  lhs(u_i,v_i) = rhs(uH,v_i) ∀ v_i ∈ V_i\n\nwhere V_i is the patch-local space indiced by the PatchDecomposition PD.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchTriangulation","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchTriangulation","text":"struct PatchTriangulation{Dc,Dp} <: Triangulation{Dc,Dp}\n  ...\nend\n\nWrapper around a Triangulation, for patch-based assembly.\n\n\n\n\n\n","category":"type"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"EditURL = \"../../../test/Applications/StokesGMG.jl\"","category":"page"},{"location":"Examples/StokesGMG/#Incompressible-Stokes-equations-in-a-2D/3D-cavity,-using-GMG.","page":"Stokes (GMG)","title":"Incompressible Stokes equations in a 2D/3D cavity, using GMG.","text":"","category":"section"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"This example solves the incompressible Stokes equations, given by","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"beginalign*\n-Delta u - nabla p = f quad textin quad Omega \nnabla cdot u = 0 quad textin quad Omega \nu = hatx quad textin quad Gamma_texttop subset partial Omega \nu = 0 quad textin quad partial Omega backslash Gamma_texttop \nendalign*","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"where Omega = 01^d.","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"We use a mixed finite-element scheme, with Q_k times P_k-1^- elements for the velocity-pressure pair.","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"To solve the linear system, we use a FGMRES solver preconditioned by a block-triangular Shur-complement-based preconditioner. We use an Augmented Lagrangian approach to get a better approximation of the Schur complement. Details for this preconditoner can be found in Benzi and Olshanskii (2006).","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"The velocity block is solved using a Geometric Multigrid (GMG) solver. Due to the kernel introduced by the Augmented-Lagrangian operator, we require special smoothers and prolongation/restriction operators. See Schoberl (1999) for more details.","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"module StokesGMGApplication\n\nusing Test\nusing LinearAlgebra\nusing FillArrays, BlockArrays\n\nusing Gridap\nusing Gridap.ReferenceFEs, Gridap.Algebra, Gridap.Geometry, Gridap.FESpaces\nusing Gridap.CellData, Gridap.MultiField, Gridap.Algebra\nusing PartitionedArrays\nusing GridapDistributed\nusing GridapP4est\n\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers, GridapSolvers.MultilevelTools, GridapSolvers.PatchBasedSmoothers\nusing GridapSolvers.BlockSolvers: LinearSystemBlock, BiformBlock, BlockTriangularSolver\n\nfunction get_patch_smoothers(mh,tests,biform,patch_decompositions,qdegree)\n  patch_spaces = PatchFESpace(tests,patch_decompositions)\n  nlevs = num_levels(mh)\n  smoothers = map(view(tests,1:nlevs-1),patch_decompositions,patch_spaces) do tests, PD, Ph\n    Vh = get_fe_space(tests)\n    Ω  = Triangulation(PD)\n    dΩ = Measure(Ω,qdegree)\n    ap = (u,v) -> biform(u,v,dΩ)\n    patch_smoother = PatchBasedLinearSolver(ap,Ph,Vh)\n    return RichardsonSmoother(patch_smoother,10,0.2)\n  end\n  return smoothers\nend\n\nfunction get_bilinear_form(mh_lev,biform,qdegree)\n  model = get_model(mh_lev)\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n  return (u,v) -> biform(u,v,dΩ)\nend\n\nfunction add_labels_2d!(labels)\n  add_tag_from_tags!(labels,\"top\",[6])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,7,8])\nend\n\nfunction add_labels_3d!(labels)\n  add_tag_from_tags!(labels,\"top\",[22])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26])\nend\n\nfunction main(distribute,np,nc,np_per_level)\n  parts = distribute(LinearIndices((prod(np),)))\n\n  Dc = length(nc)\n  domain = (Dc == 2) ? (0,1,0,1) : (0,1,0,1,0,1)\n  add_labels! = (Dc == 2) ? add_labels_2d! : add_labels_3d!\n  mh = CartesianModelHierarchy(parts,np_per_level,domain,nc;add_labels! = add_labels!)\n  model = get_model(mh,1)\n\n  order = 2\n  qdegree = 2*(order+1)\n  reffe_u = ReferenceFE(lagrangian,VectorValue{Dc,Float64},order)\n  reffe_p = ReferenceFE(lagrangian,Float64,order-1;space=:P)\n\n  u_walls = (Dc==2) ? VectorValue(0.0,0.0) : VectorValue(0.0,0.0,0.0)\n  u_top = (Dc==2) ? VectorValue(1.0,0.0) : VectorValue(1.0,0.0,0.0)\n\n  tests_u  = TestFESpace(mh,reffe_u,dirichlet_tags=[\"walls\",\"top\"]);\n  trials_u = TrialFESpace(tests_u,[u_walls,u_top]);\n  U, V = get_fe_space(trials_u,1), get_fe_space(tests_u,1)\n  Q = TestFESpace(model,reffe_p;conformity=:L2,constraint=:zeromean)\n\n  mfs = Gridap.MultiField.BlockMultiFieldStyle()\n  X = MultiFieldFESpace([U,Q];style=mfs)\n  Y = MultiFieldFESpace([V,Q];style=mfs)\n\n  α = 1.e2\n  f = (Dc==2) ? VectorValue(1.0,1.0) : VectorValue(1.0,1.0,1.0)\n  Π_Qh = LocalProjectionMap(divergence,reffe_p,qdegree)\n  graddiv(u,v,dΩ) = ∫(α*(∇⋅v)⋅Π_Qh(u))dΩ\n  biform_u(u,v,dΩ) = ∫(∇(v)⊙∇(u))dΩ + graddiv(u,v,dΩ)\n  biform((u,p),(v,q),dΩ) = biform_u(u,v,dΩ) - ∫(divergence(v)*p)dΩ - ∫(divergence(u)*q)dΩ\n  liform((v,q),dΩ) = ∫(v⋅f)dΩ\n\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n\n  a(u,v) = biform(u,v,dΩ)\n  l(v) = liform(v,dΩ)\n  op = AffineFEOperator(a,l,X,Y)\n  A, b = get_matrix(op), get_vector(op);\n\n  biforms = map(mhl -> get_bilinear_form(mhl,biform_u,qdegree),mh)\n  patch_decompositions = PatchDecomposition(mh)\n  smoothers = get_patch_smoothers(\n    mh,tests_u,biform_u,patch_decompositions,qdegree\n  )\n  prolongations = setup_patch_prolongation_operators(\n    tests_u,biform_u,graddiv,qdegree\n  )\n  restrictions = setup_patch_restriction_operators(\n    tests_u,prolongations,graddiv,qdegree;solver=CGSolver(JacobiLinearSolver())\n  )\n  gmg = GMGLinearSolver(\n    mh,trials_u,tests_u,biforms,\n    prolongations,restrictions,\n    pre_smoothers=smoothers,\n    post_smoothers=smoothers,\n    coarsest_solver=LUSolver(),\n    maxiter=4,mode=:preconditioner,verbose=i_am_main(parts)\n  )\n\n  solver_u = gmg\n  solver_p = CGSolver(JacobiLinearSolver();maxiter=20,atol=1e-14,rtol=1.e-6,verbose=i_am_main(parts))\n  solver_u.log.depth = 2\n  solver_p.log.depth = 2\n\n  diag_blocks  = [LinearSystemBlock(),BiformBlock((p,q) -> ∫(-1.0/α*p*q)dΩ,Q,Q)]\n  bblocks = map(CartesianIndices((2,2))) do I\n    (I[1] == I[2]) ? diag_blocks[I[1]] : LinearSystemBlock()\n  end\n  coeffs = [1.0 1.0;\n            0.0 1.0]\n  P = BlockTriangularSolver(bblocks,[solver_u,solver_p],coeffs,:upper)\n  solver = FGMRESSolver(20,P;atol=1e-10,rtol=1.e-12,verbose=i_am_main(parts))\n  ns = numerical_setup(symbolic_setup(solver,A),A)\n\n  x = allocate_in_domain(A); fill!(x,0.0)\n  solve!(x,ns,b)\n  xh = FEFunction(X,x);\n\n  r = allocate_in_range(A)\n  mul!(r,A,x)\n  r .-= b\n  @test norm(r) < 1.e-7\nend\n\nend # module","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"EditURL = \"../../../test/Applications/Stokes.jl\"","category":"page"},{"location":"Examples/Stokes/#Incompressible-Stokes-equations-in-a-2D/3D-cavity","page":"Stokes","title":"Incompressible Stokes equations in a 2D/3D cavity","text":"","category":"section"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"This example solves the incompressible Stokes equations, given by","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"beginalign*\n-Delta u - nabla p = f quad textin quad Omega \nnabla cdot u = 0 quad textin quad Omega \nu = hatx quad textin quad Gamma_texttop subset partial Omega \nu = 0 quad textin quad partial Omega backslash Gamma_texttop \nendalign*","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"where Omega = 01^d.","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"We use a mixed finite-element scheme, with Q_k times P_k-1^- elements for the velocity-pressure pair.","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"To solve the linear system, we use a FGMRES solver preconditioned by a block-triangular Shur-complement-based preconditioner. We use an Augmented Lagrangian approach to get a better approximation of the Schur complement. Details for this preconditoner can be found in Benzi and Olshanskii (2006).","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"The velocity block is solved directly using an exact solver.","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"module StokesApplication\n\nusing Test\nusing LinearAlgebra\nusing FillArrays, BlockArrays\n\nusing Gridap\nusing Gridap.ReferenceFEs, Gridap.Algebra, Gridap.Geometry, Gridap.FESpaces\nusing Gridap.CellData, Gridap.MultiField, Gridap.Algebra\nusing PartitionedArrays\nusing GridapDistributed\n\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers, GridapSolvers.MultilevelTools\nusing GridapSolvers.BlockSolvers: LinearSystemBlock, BiformBlock, BlockTriangularSolver\n\nfunction add_labels_2d!(labels)\n  add_tag_from_tags!(labels,\"top\",[6])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,7,8])\nend\n\nfunction add_labels_3d!(labels)\n  add_tag_from_tags!(labels,\"top\",[22])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26])\nend\n\nfunction main(distribute,np,nc)\n  parts = distribute(LinearIndices((prod(np),)))\n\n  Dc = length(nc)\n  domain = (Dc == 2) ? (0,1,0,1) : (0,1,0,1,0,1)\n\n  model = CartesianDiscreteModel(parts,np,domain,nc)\n  add_labels! = (Dc == 2) ? add_labels_2d! : add_labels_3d!\n  add_labels!(get_face_labeling(model))\n\n  order = 2\n  qdegree = 2*(order+1)\n  reffe_u = ReferenceFE(lagrangian,VectorValue{Dc,Float64},order)\n  reffe_p = ReferenceFE(lagrangian,Float64,order-1;space=:P)\n\n  u_walls = (Dc==2) ? VectorValue(0.0,0.0) : VectorValue(0.0,0.0,0.0)\n  u_top = (Dc==2) ? VectorValue(1.0,0.0) : VectorValue(1.0,0.0,0.0)\n\n  V = TestFESpace(model,reffe_u,dirichlet_tags=[\"walls\",\"top\"]);\n  U = TrialFESpace(V,[u_walls,u_top]);\n  Q = TestFESpace(model,reffe_p;conformity=:L2,constraint=:zeromean)\n\n  mfs = Gridap.MultiField.BlockMultiFieldStyle()\n  X = MultiFieldFESpace([U,Q];style=mfs)\n  Y = MultiFieldFESpace([V,Q];style=mfs)\n\n  α = 1.e2\n  f = (Dc==2) ? VectorValue(1.0,1.0) : VectorValue(1.0,1.0,1.0)\n  Π_Qh = LocalProjectionMap(divergence,Q,qdegree)\n  graddiv(u,v,dΩ)  = ∫(α*(∇⋅v)⋅Π_Qh(u))dΩ\n  biform_u(u,v,dΩ) = ∫(∇(v)⊙∇(u))dΩ + graddiv(u,v,dΩ)\n  biform((u,p),(v,q),dΩ) = biform_u(u,v,dΩ) - ∫(divergence(v)*p)dΩ - ∫(divergence(u)*q)dΩ\n  liform((v,q),dΩ) = ∫(v⋅f)dΩ\n\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n\n  a(u,v) = biform(u,v,dΩ)\n  l(v) = liform(v,dΩ)\n  op = AffineFEOperator(a,l,X,Y)\n  A, b = get_matrix(op), get_vector(op);\n\n  solver_u = LUSolver()\n  solver_p = CGSolver(JacobiLinearSolver();maxiter=20,atol=1e-14,rtol=1.e-6,verbose=i_am_main(parts))\n  solver_p.log.depth = 2\n\n  bblocks = [LinearSystemBlock() LinearSystemBlock();\n             LinearSystemBlock() BiformBlock((p,q) -> ∫(-(1.0/α)*p*q)dΩ,Q,Q)]\n  coeffs = [1.0 1.0;\n            0.0 1.0]\n  P = BlockTriangularSolver(bblocks,[solver_u,solver_p],coeffs,:upper)\n  solver = FGMRESSolver(20,P;atol=1e-10,rtol=1.e-12,verbose=i_am_main(parts))\n  ns = numerical_setup(symbolic_setup(solver,A),A)\n\n  x = allocate_in_domain(A); fill!(x,0.0)\n  solve!(x,ns,b)\n\n  r = allocate_in_range(A)\n  mul!(r,A,x)\n  r .-= b\n  @test norm(r) < 1.e-7\nend\n\nend # module","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"CurrentModule = GridapSolvers.LinearSolvers","category":"page"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers","text":"","category":"section"},{"location":"LinearSolvers/#Krylov-solvers","page":"LinearSolvers","title":"Krylov solvers","text":"","category":"section"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"  CGSolver\n  MINRESSolver\n  GMRESSolver\n  FGMRESSolver\n  krylov_mul!\n  krylov_residual!","category":"page"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.CGSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.CGSolver","text":"struct CGSolver <: LinearSolver\n  ...\nend\n\nCGSolver(Pl;maxiter=1000,atol=1e-12,rtol=1.e-6,flexible=false,verbose=0,name=\"CG\")\n\nLeft-Preconditioned Conjugate Gradient solver.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.MINRESSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.MINRESSolver","text":"struct MINRESSolver <: LinearSolver \n  ...\nend\n\nMINRESSolver(m;Pl=nothing,maxiter=100,atol=1e-12,rtol=1.e-6,verbose=false,name=\"MINRES\")\n\nMINRES solver, with optional left preconditioners Pl. The preconditioner must be    symmetric and positive definite.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.GMRESSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.GMRESSolver","text":"struct GMRESSolver <: LinearSolver \n  ...\nend\n\nGMRESSolver(m;Pr=nothing,Pl=nothing,restart=false,m_add=1,maxiter=100,atol=1e-12,rtol=1.e-6,verbose=false,name=\"GMRES\")\n\nGMRES solver, with optional right and left preconditioners Pr and Pl.\n\nThe solver starts by allocating a basis of size m. Then: \n\nIf restart=true, the basis size is fixed and restarted every m iterations.\nIf restart=false, the basis size is allowed to increase. When full, the solver  allocates m_add new basis vectors.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.FGMRESSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.FGMRESSolver","text":"struct FGMRESSolver <: LinearSolver \n  ...\nend\n\nFGMRESSolver(m,Pr;Pl=nothing,restart=false,m_add=1,maxiter=100,atol=1e-12,rtol=1.e-6,verbose=false,name=\"FGMRES\")\n\nFlexible GMRES solver, with right-preconditioner Pr and optional left-preconditioner Pl.\n\nThe solver starts by allocating a basis of size m. Then: \n\nIf restart=true, the basis size is fixed and restarted every m iterations.\nIf restart=false, the basis size is allowed to increase. When full, the solver  allocates m_add new basis vectors at a time.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.krylov_mul!","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.krylov_mul!","text":"Computes the Krylov matrix-vector product \n\ny = Pl⁻¹⋅A⋅Pr⁻¹⋅x\n\nby solving\n\nPr⋅wr = x     wl = A⋅wr     Pl⋅y = wl\n\n\n\n\n\n","category":"function"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.krylov_residual!","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.krylov_residual!","text":"Computes the Krylov residual \n\nr = Pl⁻¹(A⋅x - b)\n\nby solving\n\nw = A⋅x - b     Pl⋅r = w\n\n\n\n\n\n","category":"function"},{"location":"LinearSolvers/#Smoothers","page":"LinearSolvers","title":"Smoothers","text":"","category":"section"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"Given a linear system Ax = b, a smoother is an operator S that takes an iterative solution x_k and its residual r_k = b - A x_k, and modifies them in place","category":"page"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"  S  (x_kr_k) rightarrow (x_k+1r_k+1)","category":"page"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"such that r_k+1  r_k.","category":"page"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"  RichardsonSmoother\n  RichardsonSmoother(M::LinearSolver)","category":"page"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.RichardsonSmoother","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.RichardsonSmoother","text":"struct RichardsonSmoother{A} <: LinearSolver\n  M     :: A\n  niter :: Int64\n  ω     :: Float64\nend\n\nIterative Richardson smoother. Given a solution x and a residual r, performs niter Richardson iterations with damping parameter ω using the linear solver M.  A Richardson iteration is given by:\n\ndx = ω * inv(M) * r\nx  = x + dx\nr  = r - A * dx\n\nUpdates both the solution x and the residual r in place.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.RichardsonSmoother-Tuple{Gridap.Algebra.LinearSolver}","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.RichardsonSmoother","text":"function RichardsonSmoother(M::LinearSolver,niter::Int=1,ω::Float64=1.0)\n\nReturns an instance of RichardsonSmoother from its underlying properties.\n\n\n\n\n\n","category":"method"},{"location":"LinearSolvers/#Preconditioners","page":"LinearSolvers","title":"Preconditioners","text":"","category":"section"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"Given a linear system Ax = b, a preconditioner is an operator that takes an iterative residual r_k and returns a correction dx_k.","category":"page"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"  JacobiLinearSolver\n  GMGLinearSolverFromMatrices\n  GMGLinearSolverFromWeakform\n  GMGLinearSolver","category":"page"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.JacobiLinearSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.JacobiLinearSolver","text":"struct JacobiLinearSolver <: LinearSolver end\n\nGiven a matrix A, the Jacobi or Diagonal preconditioner is defined as P = diag(A).\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.GMGLinearSolverFromMatrices","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.GMGLinearSolverFromMatrices","text":"struct GMGLinearSolverFromMatrices <: LinearSolver\n  ...\nend\n\nGeometric MultiGrid solver, from algebraic parts.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.GMGLinearSolverFromWeakform","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.GMGLinearSolverFromWeakform","text":"struct GMGLinearSolverFromWeakForm <: LinearSolver\n  ...\nend\n\nGeometric MultiGrid solver, from FE parts.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.GMGLinearSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.GMGLinearSolver","text":"GMGLinearSolver(\n  mh::ModelHierarchy,\n  matrices::AbstractArray{<:AbstractMatrix},\n  prolongations,\n  restrictions;\n  pre_smoothers   = Fill(RichardsonSmoother(JacobiLinearSolver(),10),num_levels(mh)-1),\n  post_smoothers  = pre_smoothers,\n  coarsest_solver = LUSolver(),\n  mode::Symbol    = :preconditioner,\n  maxiter = 100, atol = 1.0e-14, rtol = 1.0e-08, verbose = false,\n)\n\nCreates an instance of GMGLinearSolverFromMatrices from the underlying model  hierarchy, the system matrices at each level and the transfer operators and smoothers  at each level except the coarsest.\n\nThe solver has two modes of operation, defined by the kwarg mode:\n\n:solver: The GMG solver takes a rhs b and returns a solution x.\n:preconditioner: The GMG solver takes a residual r and returns a correction dx.\n\n\n\n\n\nGMGLinearSolver(\n  mh::ModelHierarchy,\n  trials::FESpaceHierarchy,\n  tests::FESpaceHierarchy,\n  biforms::AbstractArray{<:Function},\n  interp,\n  restrict;\n  pre_smoothers   = Fill(RichardsonSmoother(JacobiLinearSolver(),10),num_levels(mh)-1),\n  post_smoothers  = pre_smoothers,\n  coarsest_solver = Gridap.Algebra.LUSolver(),\n  mode::Symbol    = :preconditioner,\n  is_nonlinear    = false,\n  maxiter = 100, atol = 1.0e-14, rtol = 1.0e-08, verbose = false,\n)\n\nCreates an instance of GMGLinearSolverFromMatrices from the underlying model  hierarchy, the trial and test FEspace hierarchies, the weakform lhs at each level  and the transfer operators and smoothers at each level except the coarsest.\n\nThe solver has two modes of operation, defined by the kwarg mode:\n\n:solver: The GMG solver takes a rhs b and returns a solution x.\n:preconditioner: The GMG solver takes a residual r and returns a correction dx.\n\n\n\n\n\n","category":"function"},{"location":"LinearSolvers/#Wrappers","page":"LinearSolvers","title":"Wrappers","text":"","category":"section"},{"location":"LinearSolvers/#PETSc","page":"LinearSolvers","title":"PETSc","text":"","category":"section"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"Building on top of GridapPETSc.jl, GridapSolvers provides specific solvers for some particularly complex PDEs:","category":"page"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"  ElasticitySolver\n  ElasticitySolver(::FESpace)\n  CachedPETScNS\n  CachedPETScNS(::GridapPETSc.PETScLinearSolverNS,::AbstractVector,::AbstractVector)\n  get_dof_coordinates","category":"page"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.ElasticitySolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.ElasticitySolver","text":"struct ElasticitySolver <: LinearSolver\n  ...\nend\n\nGMRES + AMG solver, specifically designed for linear elasticity problems.\n\nFollows PETSc's documentation for PCAMG    and MatNullSpaceCreateRigidBody.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.ElasticitySolver-Tuple{Gridap.FESpaces.FESpace}","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.ElasticitySolver","text":"function ElasticitySolver(space::FESpace; maxiter=500, atol=1.e-12, rtol=1.e-8)\n\nReturns an instance of ElasticitySolver from its underlying properties.\n\n\n\n\n\n","category":"method"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.CachedPETScNS","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.CachedPETScNS","text":"struct CachedPETScNS <: NumericalSetup\n  ...\nend\n\nWrapper around a PETSc NumericalSetup, providing highly efficiend reusable caches:\n\nWhen converting julia vectors/PVectors to PETSc vectors, we purposely create aliasing    of the vector values. This means we can avoid copying data from one to another before solving,    but we need to be careful about it. \n\nThis structure takes care of this, and makes sure you do not attempt to solve the system    with julia vectors that are not the ones you used to create the solver cache.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.CachedPETScNS-Tuple{GridapPETSc.PETScLinearSolverNS, AbstractVector, AbstractVector}","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.CachedPETScNS","text":"function CachedPETScNS(ns::PETScLinearSolverNS,x::AbstractVector,b::AbstractVector)\n\nCreate a new instance of CachedPETScNS from its underlying properties. Once this structure is created, you can only solve the system with the same vectors  you used to create it.\n\n\n\n\n\n","category":"method"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.get_dof_coordinates","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.get_dof_coordinates","text":"get_dof_coordinates(space::FESpace)\n\nGiven a lagrangian FESpace, returns the physical coordinates of the DoFs, as required    by some PETSc solvers. See PETSc documentation.\n\n\n\n\n\n","category":"function"},{"location":"LinearSolvers/#IterativeSolvers.jl","page":"LinearSolvers","title":"IterativeSolvers.jl","text":"","category":"section"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"GridapSolvers provides wrappers for some iterative solvers from the package IterativeSolvers.jl:","category":"page"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"  IterativeLinearSolver\n  IS_ConjugateGradientSolver\n  IS_GMRESSolver\n  IS_MINRESSolver\n  IS_SSORSolver","category":"page"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.IterativeLinearSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.IterativeLinearSolver","text":"struct IterativeLinearSolver <: LinearSolver\n  ...\nend\n\nWrappers for IterativeSolvers.jl   krylov-like iterative solvers.\n\nAll wrappers take the same kwargs as the corresponding solver in IterativeSolvers.jl.\n\nThe following solvers are available:\n\nIS_ConjugateGradientSolver\nIS_GMRESSolver\nIS_MINRESSolver\nIS_SSORSolver\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.IS_ConjugateGradientSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.IS_ConjugateGradientSolver","text":"IS_ConjugateGradientSolver(;kwargs...)\n\nWrapper for the Conjugate Gradient solver.\n\n\n\n\n\n","category":"function"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.IS_GMRESSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.IS_GMRESSolver","text":"IS_GMRESSolver(;kwargs...)\n\nWrapper for the GMRES solver.\n\n\n\n\n\n","category":"function"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.IS_MINRESSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.IS_MINRESSolver","text":"IS_MINRESSolver(;kwargs...)\n\nWrapper for the MINRES solver.\n\n\n\n\n\n","category":"function"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.IS_SSORSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.IS_SSORSolver","text":"IS_SSORSolver(ω;kwargs...)\n\nWrapper for the SSOR solver.\n\n\n\n\n\n","category":"function"},{"location":"Examples/DarcyGMG/","page":"Darcy (GMG)","title":"Darcy (GMG)","text":"EditURL = \"../../../test/Applications/DarcyGMG.jl\"","category":"page"},{"location":"Examples/DarcyGMG/","page":"Darcy (GMG)","title":"Darcy (GMG)","text":"module DarcyGMGApplication\n\nusing Test\nusing LinearAlgebra\nusing FillArrays, BlockArrays\n\nusing Gridap\nusing Gridap.ReferenceFEs, Gridap.Algebra, Gridap.Geometry, Gridap.FESpaces\nusing Gridap.CellData, Gridap.MultiField, Gridap.Algebra\nusing PartitionedArrays\nusing GridapDistributed\n\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers, GridapSolvers.MultilevelTools, GridapSolvers.PatchBasedSmoothers\nusing GridapSolvers.BlockSolvers: LinearSystemBlock, BiformBlock, BlockTriangularSolver\n\nfunction get_patch_smoothers(mh,tests,biform,patch_decompositions,qdegree)\n  patch_spaces = PatchFESpace(tests,patch_decompositions)\n  nlevs = num_levels(mh)\n  smoothers = map(view(tests,1:nlevs-1),patch_decompositions,patch_spaces) do tests, PD, Ph\n    Vh = get_fe_space(tests)\n    Ω  = Triangulation(PD)\n    dΩ = Measure(Ω,qdegree)\n    ap = (u,v) -> biform(u,v,dΩ)\n    patch_smoother = PatchBasedLinearSolver(ap,Ph,Vh)\n    return RichardsonSmoother(patch_smoother,10,0.2)\n  end\n  return smoothers\nend\n\nfunction get_bilinear_form(mh_lev,biform,qdegree)\n  model = get_model(mh_lev)\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n  return (u,v) -> biform(u,v,dΩ)\nend\n\nfunction main(distribute,np,nc,np_per_level)\n  parts = distribute(LinearIndices((prod(np),)))\n\n  Dc = length(nc)\n  domain = (Dc == 2) ? (0,1,0,1) : (0,1,0,1,0,1)\n  mh = CartesianModelHierarchy(parts,np_per_level,domain,nc)\n  model = get_model(mh,1)\n\n  order = 2\n  qdegree = 2*(order+1)\n  reffe_u = ReferenceFE(raviart_thomas,Float64,order-1)\n  reffe_p = ReferenceFE(lagrangian,Float64,order-1;space=:P)\n\n  u_exact(x) = (Dc==2) ? VectorValue(x[1]+x[2],-x[2]) : VectorValue(x[1]+x[2],-x[2],0.0)\n  p_exact(x) = 2.0*x[1]-1.0\n\n  tests_u  = TestFESpace(mh,reffe_u,dirichlet_tags=[\"boundary\"]);\n  trials_u = TrialFESpace(tests_u,[u_exact]);\n  U, V = get_fe_space(trials_u,1), get_fe_space(tests_u,1)\n  Q = TestFESpace(model,reffe_p;conformity=:L2)\n\n  mfs = Gridap.MultiField.BlockMultiFieldStyle()\n  X = MultiFieldFESpace([U,Q];style=mfs)\n  Y = MultiFieldFESpace([V,Q];style=mfs)\n\n  α = 1.e2\n  f(x) = u_exact(x) + ∇(p_exact)(x)\n  graddiv(u,v,dΩ) = ∫(α*divergence(u)⋅divergence(v))dΩ\n  biform_u(u,v,dΩ) = ∫(v⊙u)dΩ + graddiv(u,v,dΩ)\n  biform((u,p),(v,q),dΩ) = biform_u(u,v,dΩ) - ∫(divergence(v)*p)dΩ - ∫(divergence(u)*q)dΩ\n  liform((v,q),dΩ) = ∫(v⋅f)dΩ\n\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n\n  a(u,v) = biform(u,v,dΩ)\n  l(v) = liform(v,dΩ)\n  op = AffineFEOperator(a,l,X,Y)\n  A, b = get_matrix(op), get_vector(op);\n\n  biforms = map(mhl -> get_bilinear_form(mhl,biform_u,qdegree),mh)\n  patch_decompositions = PatchDecomposition(mh)\n  smoothers = get_patch_smoothers(\n    mh,tests_u,biform_u,patch_decompositions,qdegree\n  )\n  prolongations = setup_prolongation_operators(\n    tests_u,qdegree;mode=:residual\n  )\n  restrictions = setup_restriction_operators(\n    tests_u,qdegree;mode=:residual,solver=IS_ConjugateGradientSolver(;reltol=1.e-6)\n  )\n\n  gmg = GMGLinearSolver(\n    mh,trials_u,tests_u,biforms,\n    prolongations,restrictions,\n    pre_smoothers=smoothers,\n    post_smoothers=smoothers,\n    coarsest_solver=LUSolver(),\n    maxiter=3,mode=:preconditioner,verbose=i_am_main(parts)\n  )\n\n  solver_u = gmg\n  solver_p = CGSolver(JacobiLinearSolver();maxiter=20,atol=1e-14,rtol=1.e-6,verbose=i_am_main(parts))\n  solver_p.log.depth = 2\n\n  bblocks  = [LinearSystemBlock() LinearSystemBlock();\n              LinearSystemBlock() BiformBlock((p,q) -> ∫(-1.0/α*p*q)dΩ,Q,Q)]\n  coeffs = [1.0 1.0;\n            0.0 1.0]\n  P = BlockTriangularSolver(bblocks,[solver_u,solver_p],coeffs,:upper)\n  solver = FGMRESSolver(20,P;atol=1e-14,rtol=1.e-10,verbose=i_am_main(parts))\n  ns = numerical_setup(symbolic_setup(solver,A),A)\n\n  x = allocate_in_domain(A); fill!(x,0.0)\n  solve!(x,ns,b)\n\n  r = allocate_in_range(A)\n  mul!(r,A,x)\n  r .-= b\n  @test norm(r) < 1.e-5\nend\n\nend # module","category":"page"},{"location":"Examples/DarcyGMG/","page":"Darcy (GMG)","title":"Darcy (GMG)","text":"","category":"page"},{"location":"Examples/DarcyGMG/","page":"Darcy (GMG)","title":"Darcy (GMG)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"NonlinearSolvers/","page":"NonlinearSolvers","title":"NonlinearSolvers","text":"CurrentModule = GridapSolvers.NonlinearSolvers","category":"page"},{"location":"NonlinearSolvers/#GridapSolvers.NonlinearSolvers","page":"NonlinearSolvers","title":"GridapSolvers.NonlinearSolvers","text":"","category":"section"},{"location":"NonlinearSolvers/","page":"NonlinearSolvers","title":"NonlinearSolvers","text":"Modules = [NonlinearSolvers,]","category":"page"},{"location":"NonlinearSolvers/#GridapSolvers.NonlinearSolvers.NLsolveNonlinearSolver","page":"NonlinearSolvers","title":"GridapSolvers.NonlinearSolvers.NLsolveNonlinearSolver","text":"NLsolveNonlinearSolver <: NonlinearSolver\n\nNLsolveNonlinearSolver(ls::LinearSolver;kwargs...)\nNLsolveNonlinearSolver(;kwargs...)\n\nWrapper for NLsolve.jl nonlinear solvers. It is equivalent to the wrappers in Gridap, but  with support for nonlinear preconditioners. Same kwargs as in nlsolve. Due to NLSolve.jl not using LinearAlgebra's API, these solvers are not compatible with PartitionedArrays.jl. For parallel computations, use NewtonSolver instead.\n\n\n\n\n\n","category":"type"},{"location":"NonlinearSolvers/#GridapSolvers.NonlinearSolvers.NewtonSolver","page":"NonlinearSolvers","title":"GridapSolvers.NonlinearSolvers.NewtonSolver","text":"struct NewtonSolver <: Algebra.NonlinearSolver\n\nNewton-Raphson solver. Same as NewtonRaphsonSolver in Gridap, but with a couple addons: \n\nBetter logging and verbosity control.\nBetter convergence criteria. \nWorks with geometric LinearSolvers/Preconditioners. \n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GridapSolvers","category":"page"},{"location":"#GridapSolvers","page":"Home","title":"GridapSolvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GridapSolvers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GridapSolvers provides algebraic and non-algebraic solvers for the Gridap ecosystem, designed with High Performance Computing (HPC) in mind.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solvers follow a modular design, where most blocks can be combined to produce PDE-taylored solvers for a wide range of problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"SolverInterfaces.md\",\n  \"MultilevelTools.md\",\n  \"LinearSolvers.md\",\n  \"NonlinearSolvers.md\",\n  \"BlockSolvers.md\",\n  \"PatchBasedSmoothers.md\"\n  ]","category":"page"}]
}
