var documenterSearchIndex = {"docs":
[{"location":"Examples/NavierStokesGMG/#Incompressible-Navier-Stokes-equations-in-a-2D/3D-cavity,-using-GMG.","page":"Navier-Stokes (GMG)","title":"Incompressible Navier-Stokes equations in a 2D/3D cavity, using GMG.","text":"","category":"section"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"This example solves the incompressible Stokes equations, given by","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"beginalign*\n-Delta u + textR_e (u nabla) u - nabla p = f quad textin quad Omega \nnabla cdot u = 0 quad textin quad Omega \nu = hatx quad textin quad Gamma_texttop subset partial Omega \nu = 0 quad textin quad partial Omega backslash Gamma_texttop \nendalign*","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"where Omega = 01^d.","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"We use a mixed finite-element scheme, with Q_k times P_k-1^- elements for the velocity-pressure pair.","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"To solve the linear system, we use a FGMRES solver preconditioned by a block-triangular Shur-complement-based preconditioner. We use an Augmented Lagrangian approach to get a better approximation of the Schur complement. Details for this preconditoner can be found in Benzi and Olshanskii (2006).","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"The velocity block is solved using a Geometric Multigrid (GMG) solver. Due to the kernel introduced by the Augmented-Lagrangian operator, we require special smoothers and prolongation/restriction operators. See Schoberl (1999) for more details.","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"module NavierStokesGMGApplication\n\nusing Test\nusing LinearAlgebra\nusing FillArrays, BlockArrays\n\nusing Gridap\nusing Gridap.ReferenceFEs, Gridap.Algebra, Gridap.Geometry, Gridap.FESpaces\nusing Gridap.CellData, Gridap.MultiField, Gridap.Algebra\nusing PartitionedArrays\nusing GridapDistributed\n\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers, GridapSolvers.MultilevelTools\nusing GridapSolvers.PatchBasedSmoothers, GridapSolvers.NonlinearSolvers\nusing GridapSolvers.BlockSolvers: NonlinearSystemBlock, LinearSystemBlock, BiformBlock, BlockTriangularSolver\n\nfunction get_patch_smoothers(mh,tests,biform,patch_decompositions,qdegree;is_nonlinear=false)\n  patch_spaces = PatchFESpace(tests,patch_decompositions)\n  nlevs = num_levels(mh)\n  smoothers = map(view(tests,1:nlevs-1),patch_decompositions,patch_spaces) do tests, PD, Ph\n    Vh = get_fe_space(tests)\n    Ω  = Triangulation(PD)\n    dΩ = Measure(Ω,qdegree)\n    ap = (u,du,dv) -> biform(u,du,dv,dΩ)\n    patch_smoother = PatchBasedLinearSolver(ap,Ph,Vh;is_nonlinear)\n    return RichardsonSmoother(patch_smoother,10,0.2)\n  end\n  return smoothers\nend\n\nfunction get_trilinear_form(mh_lev,triform,qdegree)\n  model = get_model(mh_lev)\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n  return (u,du,dv) -> triform(u,du,dv,dΩ)\nend\n\nfunction add_labels_2d!(labels)\n  add_tag_from_tags!(labels,\"top\",[6])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,7,8])\nend\n\nfunction add_labels_3d!(labels)\n  add_tag_from_tags!(labels,\"top\",[22])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26])\nend\n\nfunction main(distribute,np,nc,np_per_level)\n  parts = distribute(LinearIndices((prod(np),)))\n\n  Dc = length(nc)\n  domain = (Dc == 2) ? (0,1,0,1) : (0,1,0,1,0,1)\n  add_labels! = (Dc == 2) ? add_labels_2d! : add_labels_3d!\n  mh = CartesianModelHierarchy(parts,np_per_level,domain,nc;add_labels! = add_labels!)\n  model = get_model(mh,1)\n\n  order = 2\n  qdegree = 2*(order+1)\n  reffe_u = ReferenceFE(lagrangian,VectorValue{Dc,Float64},order)\n  reffe_p = ReferenceFE(lagrangian,Float64,order-1;space=:P)\n\n  u_walls = (Dc==2) ? VectorValue(0.0,0.0) : VectorValue(0.0,0.0,0.0)\n  u_top = (Dc==2) ? VectorValue(1.0,0.0) : VectorValue(1.0,0.0,0.0)\n\n  tests_u  = TestFESpace(mh,reffe_u,dirichlet_tags=[\"walls\",\"top\"]);\n  trials_u = TrialFESpace(tests_u,[u_walls,u_top]);\n  U, V = get_fe_space(trials_u,1), get_fe_space(tests_u,1)\n  Q = TestFESpace(model,reffe_p;conformity=:L2,constraint=:zeromean)\n\n  mfs = Gridap.MultiField.BlockMultiFieldStyle()\n  X = MultiFieldFESpace([U,Q];style=mfs)\n  Y = MultiFieldFESpace([V,Q];style=mfs)\n\n  Re = 10.0\n  ν = 1/Re\n  α = 1.e2\n  f = (Dc==2) ? VectorValue(1.0,1.0) : VectorValue(1.0,1.0,1.0)\n\n  Π_Qh = LocalProjectionMap(divergence,reffe_p,qdegree)\n  graddiv(u,v,dΩ) = ∫(α*(∇⋅v)⋅Π_Qh(u))dΩ\n\n  conv(u,∇u) = (∇u')⋅u\n  dconv(du,∇du,u,∇u) = conv(u,∇du)+conv(du,∇u)\n  c(u,v,dΩ) = ∫(v⊙(conv∘(u,∇(u))))dΩ\n  dc(u,du,dv,dΩ) = ∫(dv⊙(dconv∘(du,∇(du),u,∇(u))))dΩ\n\n  lap(u,v,dΩ) = ∫(ν*∇(v)⊙∇(u))dΩ\n  rhs(v,dΩ) = ∫(v⋅f)dΩ\n\n  jac_u(u,du,dv,dΩ) = lap(du,dv,dΩ) + dc(u,du,dv,dΩ) + graddiv(du,dv,dΩ)\n  jac((u,p),(du,dp),(dv,dq),dΩ) = jac_u(u,du,dv,dΩ) - ∫(divergence(dv)*dp)dΩ - ∫(divergence(du)*dq)dΩ\n\n  res_u(u,v,dΩ) = lap(u,v,dΩ) + c(u,v,dΩ) + graddiv(u,v,dΩ) - rhs(v,dΩ)\n  res((u,p),(v,q),dΩ) = res_u(u,v,dΩ) - ∫(divergence(v)*p)dΩ - ∫(divergence(u)*q)dΩ\n\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n  jac_h(x,dx,dy) = jac(x,dx,dy,dΩ)\n  res_h(x,dy) = res(x,dy,dΩ)\n  op = FEOperator(res_h,jac_h,X,Y)\n\n  biforms = map(mhl -> get_trilinear_form(mhl,jac_u,qdegree),mh)\n  patch_decompositions = PatchDecomposition(mh)\n  smoothers = get_patch_smoothers(\n    mh,trials_u,jac_u,patch_decompositions,qdegree;is_nonlinear=true\n  )\n  prolongations = setup_patch_prolongation_operators(\n    tests_u,jac_u,graddiv,qdegree;is_nonlinear=true\n  )\n  restrictions = setup_patch_restriction_operators(\n    tests_u,prolongations,graddiv,qdegree;solver=CGSolver(JacobiLinearSolver())\n  )\n  gmg = GMGLinearSolver(\n    trials_u,tests_u,biforms,\n    prolongations,restrictions,\n    pre_smoothers=smoothers,\n    post_smoothers=smoothers,\n    coarsest_solver=LUSolver(),\n    maxiter=2,mode=:preconditioner,verbose=i_am_main(parts),is_nonlinear=true\n  )\n\n  solver_u = gmg\n  solver_p = CGSolver(JacobiLinearSolver();maxiter=20,atol=1e-14,rtol=1.e-6,verbose=i_am_main(parts))\n  solver_u.log.depth = 3\n  solver_p.log.depth = 3\n\n  bblocks  = [NonlinearSystemBlock([1]) LinearSystemBlock();\n              LinearSystemBlock()       BiformBlock((p,q) -> ∫(-(1.0/α)*p*q)dΩ,Q,Q)]\n  coeffs = [1.0 1.0;\n            0.0 1.0]\n  P = BlockTriangularSolver(bblocks,[solver_u,solver_p],coeffs,:upper)\n  solver = FGMRESSolver(20,P;atol=1e-11,rtol=1.e-8,verbose=i_am_main(parts))\n  solver.log.depth = 2\n\n  nlsolver = NewtonSolver(solver;maxiter=20,atol=1e-10,rtol=1.e-12,verbose=i_am_main(parts))\n  xh = solve(nlsolver,op)\n\n  @test true\nend\n\nend # module","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"","category":"page"},{"location":"Examples/NavierStokesGMG/","page":"Navier-Stokes (GMG)","title":"Navier-Stokes (GMG)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Extensions/Pardiso/#Pardiso.jl-extension","page":"Pardiso.jl","title":"Pardiso.jl extension","text":"","category":"section"},{"location":"Extensions/Pardiso/","page":"Pardiso.jl","title":"Pardiso.jl","text":"GridapSolvers provides a wrapper for the Pardiso library, through Pardiso.jl:","category":"page"},{"location":"Extensions/Pardiso/#GridapSolvers.PardisoLinearSolver","page":"Pardiso.jl","title":"GridapSolvers.PardisoLinearSolver","text":"PardisoLinearSolver(; lib = :MKL, mtype = REAL_NONSYM, nthreads = 1, verbose = false)\n\nInterface with the Pardiso.jl library, which provides access to the PARDISO solver.  Check out the Pardiso.jl package for more details.\n\nArguments\n\nlib: The library to use, either :MKL (for Pardiso.MKLPardisoSolver) or :Pardiso (for Pardiso.PardisoSolver).         Defaults to :MKL.\nmtype: The matrix type to use. Gets passed to the solver using Pardiso.set_matrixtype!.         Defaults to Pardiso.REAL_NONSYM.\nnthreads: The number of threads to use for the solver. Gets passed to the solver using Pardiso.set_nprocs!.             Defaults to 1.\nverbose: If true, enables verbose output from the solver by setting the message level to MESSAGE_LEVEL_ON.\n\n\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools","text":"","category":"section"},{"location":"MultilevelTools/#Nested-subpartitions","page":"MultilevelTools","title":"Nested subpartitions","text":"","category":"section"},{"location":"MultilevelTools/","page":"MultilevelTools","title":"MultilevelTools","text":"One of the main difficulties of multilevel algorithms is dealing with the complexity of having multiple subcommunicators. We provide some tools to deal with it. In particular we introduce HierarchicalArrays.","category":"page"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.generate_level_parts","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.generate_level_parts","text":"generate_level_parts(root_parts::AbstractArray,num_procs_x_level::Vector{<:Integer})\n\nFrom a root communicator root_parts, generate a sequence of nested    subcommunicators with sizes given by num_procs_x_level.\n\n\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.HierarchicalArray","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.HierarchicalArray","text":"HierarchicalArray{T,A,B} <: AbstractVector{T}\n\nArray of hierarchical (nested) distributed objects. Each level might live in a different subcommunicator. If a processor does not belong to  subcommunicator ranks[i], then array[i] is nothing.\n\nHowever, it assumes: \n\nThe subcommunicators are nested, so that ranks[i] contains ranks[i+1].\nThe first subcommunicator does not have empty parts.\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#Base.map","page":"MultilevelTools","title":"Base.map","text":"Base.map(f::Function,args::Vararg{HierarchicalArray,N}) where N\n\nMaps a function to a set of HierarchicalArrays. The function is applied only in the   subcommunicators where the processor belongs to.\n\n\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.with_level","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.with_level","text":"with_level(f::Function,a::HierarchicalArray,lev::Integer;default=nothing)\n\nApplies a function to the lev-th level of a HierarchicalArray. If the processor does not belong to the subcommunicator of the lev-th level, then default is returned.\n\n\n\n\n\n","category":"function"},{"location":"MultilevelTools/#ModelHierarchies-and-FESpaceHierarchies","page":"MultilevelTools","title":"ModelHierarchies and FESpaceHierarchies","text":"","category":"section"},{"location":"MultilevelTools/","page":"MultilevelTools","title":"MultilevelTools","text":"This objects are the multilevel counterparts of Gridap's DiscreteModel and FESpace.","category":"page"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.ModelHierarchy","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.ModelHierarchy","text":"const ModelHierarchy = HierarchicalArray{<:ModelHierarchyLevel}\n\nA ModelHierarchy is a hierarchical array of ModelHierarchyLevel objects. It stores the  adapted/redistributed models and the corresponding subcommunicators.\n\nFor convenience, implements some of the API of DiscreteModel.\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.ModelHierarchyLevel","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.ModelHierarchyLevel","text":"struct ModelHierarchyLevel{A,B,C,D}\n  level     :: Int\n  model     :: A\n  ref_glue  :: B\n  model_red :: C\n  red_glue  :: D\nend\n\nSingle level for a ModelHierarchy.\n\nNote that model_red and red_glue might be of type Nothing whenever there is no redistribution in a given level.\n\nref_glue is of type Nothing on the coarsest level.\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.CartesianModelHierarchy","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.CartesianModelHierarchy","text":"CartesianModelHierarchy(\n  ranks::AbstractVector{<:Integer},\n  np_per_level::Vector{<:NTuple{D,<:Integer}},\n  domain::Tuple,\n  nc::NTuple{D,<:Integer};\n  nrefs::Union{<:Integer,Vector{<:Integer},Vector{<:NTuple{D,<:Integer}},NTuple{D,<:Integer}},\n  map::Function = identity,\n  isperiodic::NTuple{D,Bool} = Tuple(fill(false,D)),\n  add_labels!::Function = (labels -> nothing),\n) where D\n\nReturns a ModelHierarchy with a Cartesian model as coarsest level. The i-th level  will be distributed among np_per_level[i] processors. Two consecutive levels are  refined by a factor of nrefs[i].\n\nParameters:\n\nranks: Initial communicator. Will be used to generate subcommunicators.\ndomain: Tuple containing the domain limits.\nnc: Tuple containing the number of cells in each direction for the coarsest model.\nnp_per_level: Vector containing the number of processors we want to distribute each level into. Requires a tuple np = (np_1,...,np_d) for each level, then each  level will be distributed among prod(np) processors with np_i processors in the i-th direction.\nnrefs: Vector containing the refinement factor for each level. Has nlevs-1 entries,    and each entry can either be an integer (homogeneous refinement) or a tuple    with D integers (inhomogeneous refinement).\n\n\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.FESpaceHierarchy","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.FESpaceHierarchy","text":"const FESpaceHierarchy = HierarchicalArray{<:FESpaceHierarchyLevel}\n\nA FESpaceHierarchy is a hierarchical array of FESpaceHierarchyLevel objects. It stores the  adapted/redistributed fe spaces and the corresponding subcommunicators.\n\nFor convenience, implements some of the API of FESpace.\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#Grid-transfer-operators","page":"MultilevelTools","title":"Grid transfer operators","text":"","category":"section"},{"location":"MultilevelTools/","page":"MultilevelTools","title":"MultilevelTools","text":"To move information between different levels, we will require grid transfer operators. Although any custom-made operator can be used, we provide some options.","category":"page"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.DistributedGridTransferOperator","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.DistributedGridTransferOperator","text":"\n\n\n\n","category":"type"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.RestrictionOperator","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.RestrictionOperator","text":"\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.ProlongationOperator","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.ProlongationOperator","text":"\n\n\n\n","category":"function"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.MultiFieldTransferOperator","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.MultiFieldTransferOperator","text":"\n\n\n\n","category":"type"},{"location":"MultilevelTools/#Local-projection-maps","page":"MultilevelTools","title":"Local projection maps","text":"","category":"section"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.LocalProjectionMap","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.LocalProjectionMap","text":"abstract type LocalProjectionMap{T} <: Map end\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.ReffeProjectionMap","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.ReffeProjectionMap","text":"struct ReffeProjectionMap{T} <: LocalProjectionMap{T}\n  op      :: Operation{T}\n  reffe   :: Tuple{<:ReferenceFEName,Any,Any}\n  qdegree :: Int\nend\n\nMap that projects a field/field-basis onto another local reference space  given by a ReferenceFE.\n\nExample:\n\nmodel = CartesianDiscreteModel((0,1,0,1),(2,2))\n\nreffe_h1 = ReferenceFE(QUAD,lagrangian,Float64,1,space=:Q)\nreffe_l2 = ReferenceFE(QUAD,lagrangian,Float64,1,space=:P)\nU = FESpace(model,reffe_h1)\nu_h1 = interpolate(f,U)\n\nΩ = Triangulation(model)\ndΩ = Measure(Ω,2)\n\nΠ = LocalProjectionMap(reffe_l2)\nu_l2 = Π(u_h1,dΩ)\n\n\n\n\n\n","category":"type"},{"location":"MultilevelTools/#GridapSolvers.MultilevelTools.SpaceProjectionMap","page":"MultilevelTools","title":"GridapSolvers.MultilevelTools.SpaceProjectionMap","text":"struct SpaceProjectionMap{T} <: LocalProjectionMap{T}\n  op      :: Operation{T}\n  space   :: A\n  qdegree :: Int\nend\n\nMap that projects a CellField onto another FESpace. Necessary when the arrival space  has constraints (e.g. boundary conditions) that need to be taken into account.\n\n\n\n\n\n","category":"type"},{"location":"Examples/NavierStokes/#Incompressible-Navier-Stokes-equations-in-a-2D/3D-cavity","page":"Navier-Stokes","title":"Incompressible Navier-Stokes equations in a 2D/3D cavity","text":"","category":"section"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"This example solves the incompressible Stokes equations, given by","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"beginalign*\n-Delta u + textR_e (u nabla) u - nabla p = f quad textin quad Omega \nnabla cdot u = 0 quad textin quad Omega \nu = hatx quad textin quad Gamma_texttop subset partial Omega \nu = 0 quad textin quad partial Omega backslash Gamma_texttop \nendalign*","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"where Omega = 01^d.","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"We use a mixed finite-element scheme, with Q_k times P_k-1^- elements for the velocity-pressure pair.","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"To solve the linear system, we use a FGMRES solver preconditioned by a block-triangular Shur-complement-based preconditioner. We use an Augmented Lagrangian approach to get a better approximation of the Schur complement. Details for this preconditoner can be found in Benzi and Olshanskii (2006).","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"The velocity block is solved directly using an exact solver.","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"module NavierStokesApplication\n\nusing Test\nusing LinearAlgebra\nusing FillArrays, BlockArrays\n\nusing Gridap\nusing Gridap.ReferenceFEs, Gridap.Algebra, Gridap.Geometry, Gridap.FESpaces\nusing Gridap.CellData, Gridap.MultiField, Gridap.Algebra\nusing PartitionedArrays\nusing GridapDistributed\n\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers, GridapSolvers.MultilevelTools, GridapSolvers.NonlinearSolvers\nusing GridapSolvers.BlockSolvers: LinearSystemBlock, NonlinearSystemBlock, BiformBlock, BlockTriangularSolver\n\nfunction add_labels_2d!(labels)\n  add_tag_from_tags!(labels,\"top\",[6])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,7,8])\nend\n\nfunction add_labels_3d!(labels)\n  add_tag_from_tags!(labels,\"top\",[22])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26])\nend\n\nfunction main(distribute,np,nc)\n  parts = distribute(LinearIndices((prod(np),)))\n\n  Dc = length(nc)\n  domain = (Dc == 2) ? (0,1,0,1) : (0,1,0,1,0,1)\n  model = CartesianDiscreteModel(parts,np,domain,nc)\n  add_labels! = (Dc == 2) ? add_labels_2d! : add_labels_3d!\n  add_labels!(get_face_labeling(model))\n\n  order = 2\n  qdegree = 2*(order+1)\n  reffe_u = ReferenceFE(lagrangian,VectorValue{Dc,Float64},order)\n  reffe_p = ReferenceFE(lagrangian,Float64,order-1;space=:P)\n\n  u_walls = (Dc==2) ? VectorValue(0.0,0.0) : VectorValue(0.0,0.0,0.0)\n  u_top = (Dc==2) ? VectorValue(1.0,0.0) : VectorValue(1.0,0.0,0.0)\n\n  V = TestFESpace(model,reffe_u,dirichlet_tags=[\"walls\",\"top\"]);\n  U = TrialFESpace(V,[u_walls,u_top]);\n  Q = TestFESpace(model,reffe_p;conformity=:L2,constraint=:zeromean)\n\n  mfs = Gridap.MultiField.BlockMultiFieldStyle()\n  X = MultiFieldFESpace([U,Q];style=mfs)\n  Y = MultiFieldFESpace([V,Q];style=mfs)\n\n  Re = 10.0\n  ν = 1/Re\n  α = 1.e2\n  f = (Dc==2) ? VectorValue(0.0,0.0) : VectorValue(0.0,0.0,0.0)\n\n  Π_Qh = LocalProjectionMap(divergence,Q,qdegree)\n  graddiv(u,v,dΩ) = ∫(α*(∇⋅v)⋅Π_Qh(u))dΩ\n\n  conv(u,∇u) = (∇u')⋅u\n  dconv(du,∇du,u,∇u) = conv(u,∇du)+conv(du,∇u)\n  c(u,v,dΩ) = ∫(v⊙(conv∘(u,∇(u))))dΩ\n  dc(u,du,dv,dΩ) = ∫(dv⊙(dconv∘(du,∇(du),u,∇(u))))dΩ\n\n  lap(u,v,dΩ) = ∫(ν*∇(v)⊙∇(u))dΩ\n  rhs(v,dΩ) = ∫(v⋅f)dΩ\n\n  jac_u(u,du,dv,dΩ) = lap(du,dv,dΩ) + dc(u,du,dv,dΩ) + graddiv(du,dv,dΩ)\n  jac((u,p),(du,dp),(dv,dq),dΩ) = jac_u(u,du,dv,dΩ) - ∫(divergence(dv)*dp)dΩ - ∫(divergence(du)*dq)dΩ\n\n  res_u(u,v,dΩ) = lap(u,v,dΩ) + c(u,v,dΩ) + graddiv(u,v,dΩ) - rhs(v,dΩ)\n  res((u,p),(v,q),dΩ) = res_u(u,v,dΩ) - ∫(divergence(v)*p)dΩ - ∫(divergence(u)*q)dΩ\n\n  Ω  = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n  jac_h(x,dx,dy) = jac(x,dx,dy,dΩ)\n  res_h(x,dy) = res(x,dy,dΩ)\n  op = FEOperator(res_h,jac_h,X,Y)\n\n  solver_u = LUSolver()\n  solver_p = CGSolver(JacobiLinearSolver();maxiter=20,atol=1e-14,rtol=1.e-6,verbose=i_am_main(parts))\n  solver_p.log.depth = 4\n\n  bblocks  = [NonlinearSystemBlock() LinearSystemBlock();\n              LinearSystemBlock()    BiformBlock((p,q) -> ∫(-(1.0/α)*p*q)dΩ,Q,Q)]\n  coeffs = [1.0 1.0;\n            0.0 1.0]\n  P = BlockTriangularSolver(bblocks,[solver_u,solver_p],coeffs,:upper)\n  solver = FGMRESSolver(20,P;atol=1e-11,rtol=1.e-8,verbose=i_am_main(parts))\n  solver.log.depth = 2\n\n  nlsolver = NewtonSolver(solver;maxiter=20,atol=1e-10,rtol=1.e-12,verbose=i_am_main(parts))\n  xh = solve(nlsolver,op);\n\n  @test true\nend\n\nend # module","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"","category":"page"},{"location":"Examples/NavierStokes/","page":"Navier-Stokes","title":"Navier-Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Extensions/GridapPETSc/#GridapPETSc.jl-extension","page":"GridapPETSc.jl","title":"GridapPETSc.jl extension","text":"","category":"section"},{"location":"Extensions/GridapPETSc/","page":"GridapPETSc.jl","title":"GridapPETSc.jl","text":"Building on top of GridapPETSc.jl, GridapSolvers provides specific solvers for some particularly complex PDEs:","category":"page"},{"location":"Extensions/GridapPETSc/#GridapSolvers.PETScElasticitySolver","page":"GridapPETSc.jl","title":"GridapSolvers.PETScElasticitySolver","text":"PETScElasticitySolver(space::FESpace; maxiter=500, atol=1.e-12, rtol=1.e-8)\n\nGMRES + AMG solver, specifically designed for linear elasticity problems.\n\nFollows PETSc's documentation for PCAMG  and MatNullSpaceCreateRigidBody.\n\n\n\n\n\n","category":"function"},{"location":"Extensions/GridapPETSc/#GridapSolvers.PETScElasticitySolver-Tuple{Gridap.FESpaces.FESpace}","page":"GridapPETSc.jl","title":"GridapSolvers.PETScElasticitySolver","text":"PETScElasticitySolver(space::FESpace; maxiter=500, atol=1.e-12, rtol=1.e-8)\n\nGMRES + AMG solver, specifically designed for linear elasticity problems.\n\nFollows PETSc's documentation for PCAMG  and MatNullSpaceCreateRigidBody.\n\n\n\n\n\n","category":"method"},{"location":"Extensions/GridapPETSc/#GridapSolvers.CachedPETScNS","page":"GridapPETSc.jl","title":"GridapSolvers.CachedPETScNS","text":"CachedPETScNS(ns::PETScLinearSolverNS,x::AbstractVector,b::AbstractVector)\n\nWrapper around a PETSc NumericalSetup, providing highly efficiend reusable caches:\n\nWhen converting julia vectors/PVectors to PETSc vectors, we purposely create aliasing  of the vector values. This means we can avoid copying data from one to another before solving,  but we need to be careful about it. \n\nThis structure takes care of this, and makes sure you do not attempt to solve the system  with julia vectors that are not the ones you used to create the solver cache.  Once this structure is created, you can only solve the system with the same vectors  you used to create it.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces","text":"","category":"section"},{"location":"SolverInterfaces/#SolverTolerances","page":"SolverInterfaces","title":"SolverTolerances","text":"","category":"section"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.SolverTolerances","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.SolverTolerances","text":"mutable struct SolverTolerances{T}\n  ...\nend\n\nSolverTolerances{T}(\n  maxiter :: Int = 1000,\n  atol    :: T   = eps(T),\n  rtol    :: T   = 1.e-5,\n  dtol    :: T   = Inf\n)\n\nStructure to check convergence conditions for iterative linear solvers.\n\nMethods:\n\nget_solver_tolerances\nset_solver_tolerances!\nconverged\nfinished\nfinished_flag\n\n\n\n\n\n","category":"type"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.SolverConvergenceFlag","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.SolverConvergenceFlag","text":"@enum SolverConvergenceFlag begin\n  SOLVER_CONVERGED_ATOL     = 0\n  SOLVER_CONVERGED_RTOL     = 1\n  SOLVER_DIVERGED_MAXITER   = 2\n  SOLVER_DIVERGED_BREAKDOWN = 3\nend\n\nConvergence flags for iterative linear solvers.\n\n\n\n\n\n","category":"type"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.get_solver_tolerances","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.get_solver_tolerances","text":"get_solver_tolerances(s::LinearSolver)\n\nReturns the solver tolerances of the linear solver s.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.set_solver_tolerances!","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.set_solver_tolerances!","text":"set_solver_tolerances!(s::LinearSolver;\n  maxiter = 1000,\n  atol   = eps(T),\n  rtol   = T(1.e-5),\n  dtol   = T(Inf)\n)\n\nModifies tolerances of the linear solver s.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.finished","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.finished","text":"finished(tols::SolverTolerances,niter,e_a,e_r) :: Bool\n\nReturns true if the solver has finished, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.converged","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.converged","text":"converged(tols::SolverTolerances,niter,e_a,e_r) :: Bool\n\nReturns true if the solver has converged, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.finished_flag","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.finished_flag","text":"finished_flag(tols::SolverTolerances,niter,e_a,e_r) :: SolverConvergenceFlag\n\nComputes the solver exit condition given \n\nthe number of iterations niter\nthe absolute error e_a \nand the relative error e_r.\n\nReturns the corresponding SolverConvergenceFlag.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#ConvergenceLogs","page":"SolverInterfaces","title":"ConvergenceLogs","text":"","category":"section"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.ConvergenceLog","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.ConvergenceLog","text":"mutable struct ConvergenceLog{T}\n  ...\nend\n\nConvergenceLog(\n  name :: String,\n  tols :: SolverTolerances{T};\n  verbose = SOLVER_VERBOSE_NONE,\n  depth   = 0\n)\n\nStandarized logging system for iterative linear solvers.\n\nMethods:\n\nreset!\ninit!\nupdate!\nfinalize!\nprint_message\n\n\n\n\n\n","category":"type"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.SolverVerboseLevel","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.SolverVerboseLevel","text":"@enum SolverVerboseLevel begin\n  SOLVER_VERBOSE_NONE = 0\n  SOLVER_VERBOSE_LOW  = 1\n  SOLVER_VERBOSE_HIGH = 2\nend\n\nSolverVerboseLevel(true) = SOLVER_VERBOSE_HIGH\nSolverVerboseLevel(false) = SOLVER_VERBOSE_NONE\n\n\n\n\n\n","category":"type"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.reset!","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.reset!","text":"reset!(log::ConvergenceLog{T})\n\nResets the convergence log log to its initial state.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.init!","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.init!","text":"init!(log::ConvergenceLog{T},r0::T)\n\nInitializes the convergence log log with the initial residual r0.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.update!","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.update!","text":"update!(log::ConvergenceLog{T},r::T)\n\nUpdates the convergence log log with the residual r at the current iteration.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.finalize!","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.finalize!","text":"finalize!(log::ConvergenceLog{T},r::T)\n\nFinalizes the convergence log log with the final residual r.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.set_depth!","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.set_depth!","text":"set_depth!(log::ConvergenceLog,depth::Int)\nset_depth!(log::NonlinearSolver,depth::Int)\n\nSets the tabulation depth of the convergence log log to depth.\n\n\n\n\n\n","category":"function"},{"location":"SolverInterfaces/#GridapSolvers.SolverInterfaces.print_message","page":"SolverInterfaces","title":"GridapSolvers.SolverInterfaces.print_message","text":"print_message(log::ConvergenceLog{T},msg::String)\n\nPrints the message msg to the output stream of the convergence log log.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers","text":"","category":"section"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"Many scalable preconditioners for multiphysics problems are based on (possibly partial) block factorizations. This module provides a simple interface to define and use block solvers for block-assembled systems.","category":"page"},{"location":"BlockSolvers/#Block-types","page":"BlockSolvers","title":"Block types","text":"","category":"section"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"In a same preconditioner, blocks can come from different sources. For example, in a Schur-complement-based preconditioner you might want to solve the eliminated block (which comes from the original matrix), while having an approximation for your Schur complement (which can come from a matrix assembled in your driver, or from a weakform).","category":"page"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"For this reason, we define the following abstract interface:","category":"page"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.SolverBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.SolverBlock","text":"abstract type SolverBlock end\n\nAbstract type representing a block in a block solver. More specifically, it    indicates how a block is obtained from the original system matrix.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.LinearSolverBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.LinearSolverBlock","text":"abstract type LinearSolverBlock <: SolverBlock end\n\nSolverBlock that will not be updated between nonlinear iterations.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.NonlinearSolverBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.NonlinearSolverBlock","text":"abstract type NonlinearSolverBlock <: SolverBlock end\n\nSolverBlock that will be updated between nonlinear iterations.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"On top of this interface, we provide some useful block implementations:","category":"page"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.LinearSystemBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.LinearSystemBlock","text":"struct LinearSystemBlock <: LinearSolverBlock\n\nSolverBlock representing a linear (i.e non-updateable) block that is directly    taken from the system matrix. This block will not be updated between nonlinear    iterations.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.NonlinearSystemBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.NonlinearSystemBlock","text":"struct NonlinearSystemBlock <: LinearSolverBlock\n  I :: Vector{Int}\nend\n\nSolverBlock representing a nonlinear (i.e updateable) block that is directly    taken from the system matrix. This block will be updated between nonlinear   iterations.\n\nParameters:\n\n- `ids::Vector{Int8}`: Block indices considered when updating the nonlinear block. \n   By default, all indices are considered.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.MatrixBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.MatrixBlock","text":"struct MatrixBlock{A} <: LinearSolverBlock\n\nSolverBlock representing an external, independent matrix. \n\nParameters:\n\nmat::A: The matrix.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BiformBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BiformBlock","text":"struct BiformBlock <: LinearSolverBlock\n\nSolverBlock representing a linear block assembled from a bilinear form.    This block will be not updated between nonlinear iterations.\n\nParameters:\n\nf::Function: The bilinear form, i.e f(du,dv) = ∫(...)dΩ\ntrial::FESpace: The trial space.\ntest::FESpace: The test space.\nassem::Assembler: The assembler to use.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.TriformBlock","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.TriformBlock","text":"struct TriformBlock <: NonlinearSolverBlock\n\nSolverBlock representing a nonlinear block assembled from a trilinear form.    This block will be updated between nonlinear iterations.\n\nParameters:\n\nf::Function: The trilinear form, i.e f(u,du,dv) = ∫(...)dΩ\nparam::FESpace: The parameter space, where u lives.\ntrial::FESpace: The trial space, where du lives.\ntest::FESpace: The test space, where dv lives.\nassem::Assembler: The assembler to use.\nids::Vector{Int8}: Block indices considered when updating the nonlinear block.    By default, all indices are considered.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"To create a new type of block, one needs to implement the following implementation (similar to the one for LinearSolver):","category":"page"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.block_symbolic_setup","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.block_symbolic_setup","text":"block_symbolic_setup(block::SolverBlock,solver::LinearSolver,mat::AbstractMatrix)\nblock_symbolic_setup(block::SolverBlock,solver::LinearSolver,mat::AbstractMatrix,x::AbstractVector)\n\nGiven a SolverBlock, returns the symbolic setup associated to the LinearSolver.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.block_numerical_setup","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.block_numerical_setup","text":"block_numerical_setup(block::SolverBlock,ss::BlockSS,mat::AbstractMatrix)\nblock_numerical_setup(block::SolverBlock,ss::BlockSS,mat::AbstractMatrix,x::AbstractVector)\n\nGiven a SolverBlock, returns the numerical setup associated to it.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.block_numerical_setup!","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.block_numerical_setup!","text":"block_numerical_setup!(block::SolverBlock,ns::BlockNS,mat::AbstractMatrix)\nblock_numerical_setup!(block::SolverBlock,ns::BlockNS,mat::AbstractMatrix,x::AbstractVector)\n\nGiven a SolverBlock, updates the numerical setup associated to it.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.block_offdiagonal_setup","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.block_offdiagonal_setup","text":"block_offdiagonal_setup(block::SolverBlock,mat::AbstractMatrix)\nblock_offdiagonal_setup(block::SolverBlock,mat::AbstractMatrix,x::AbstractVector)\n\nGiven a SolverBlock, returns the off-diagonal block of associated to it.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.block_offdiagonal_setup!","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.block_offdiagonal_setup!","text":"block_offdiagonal_setup!(cache,block::SolverBlock,mat::AbstractMatrix)\nblock_offdiagonal_setup!(cache,block::SolverBlock,mat::AbstractMatrix,x::AbstractVector)\n\nGiven a SolverBlock, updates the off-diagonal block of associated to it.\n\n\n\n\n\n","category":"function"},{"location":"BlockSolvers/#Block-solvers","page":"BlockSolvers","title":"Block solvers","text":"","category":"section"},{"location":"BlockSolvers/","page":"BlockSolvers","title":"BlockSolvers","text":"We can combine blocks to define a block solver. All block solvers take an array of blocks and a vector of solvers for the diagonal blocks (which need to be solved for). We provide two common types of block solvers:","category":"page"},{"location":"BlockSolvers/#BlockDiagonalSolvers","page":"BlockSolvers","title":"BlockDiagonalSolvers","text":"","category":"section"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockDiagonalSolver","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockDiagonalSolver","text":"struct BlockDiagonalSolver{N} <: LinearSolver\n\nSolver representing a block-diagonal solver, i.e \n\n│ A11   0    0  │   │ x1 │   │ r1 │\n│  0   A22   0  │ ⋅ │ x2 │ = │ r2 │\n│  0    0   A33 │   │ x3 │   │ r3 │\n\nwhere N is the number of diagonal blocks.\n\nProperties:\n\nblocks::AbstractVector{<:SolverBlock}: Matrix of solver blocks, indicating how    each diagonal block of the preconditioner is obtained. \nsolvers::AbstractVector{<:LinearSolver}: Vector of solvers,    one for each diagonal block.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockDiagonalSolver-Tuple{AbstractVector{<:GridapSolvers.BlockSolvers.SolverBlock}, AbstractVector{<:Gridap.Algebra.LinearSolver}}","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockDiagonalSolver","text":"function BlockDiagonalSolver(\n  blocks  :: AbstractVector{<:SolverBlock},\n  solvers :: AbstractVector{<:LinearSolver}\n)\n\nCreate and instance of BlockDiagonalSolver from its underlying properties.\n\n\n\n\n\n","category":"method"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockDiagonalSolver-Tuple{AbstractVector{<:Gridap.Algebra.LinearSolver}}","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockDiagonalSolver","text":"function BlockDiagonalSolver(\n  solvers::AbstractVector{<:LinearSolver}; \n  is_nonlinear::Vector{Bool}=fill(false,length(solvers))\n)\n\nCreate and instance of BlockDiagonalSolver where all blocks are extracted from  the linear system.\n\n\n\n\n\n","category":"method"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockDiagonalSolver-Tuple{AbstractArray{<:Function}, AbstractArray{<:Gridap.FESpaces.FESpace}, AbstractArray{<:Gridap.FESpaces.FESpace}, AbstractArray{<:Gridap.Algebra.LinearSolver}}","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockDiagonalSolver","text":"function BlockDiagonalSolver(\n  funcs   :: AbstractArray{<:Function},\n  trials  :: AbstractArray{<:FESpace},\n  tests   :: AbstractArray{<:FESpace},\n  solvers :: AbstractArray{<:LinearSolver};\n  is_nonlinear::Vector{Bool}=fill(false,length(solvers))\n)\n\nCreate and instance of BlockDiagonalSolver where all blocks are given by  integral forms.\n\n\n\n\n\n","category":"method"},{"location":"BlockSolvers/#BlockTriangularSolvers","page":"BlockSolvers","title":"BlockTriangularSolvers","text":"","category":"section"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockTriangularSolver","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockTriangularSolver","text":"struct BlockTriangularSolver{T,N} <: LinearSolver\n\nSolver representing a block-triangular (upper/lower) solver, i.e \n\n│ A11  c12⋅A12  c13⋅A13 │   │ x1 │   │ r1 │\n│  0       A22  c23⋅A23 │ ⋅ │ x2 │ = │ r2 │\n│  0      0         A33 │   │ x3 │   │ r3 │\n\nwhere N is the number of diagonal blocks and T is either Val{:upper} or Val{:lower}.\n\nProperties:\n\nblocks::AbstractMatrix{<:SolverBlock}: Matrix of solver blocks, indicating how    each block of the preconditioner is obtained. \nsolvers::AbstractVector{<:LinearSolver}: Vector of solvers,    one for each diagonal block.\ncoeffs::AbstractMatrix{<:Real}: Matrix of coefficients, indicating the    contribution of the off-diagonal blocks to the right-hand side of each    diagonal. In particular, blocks can be turned off by setting the corresponding    coefficient to zero.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockTriangularSolver-Tuple{AbstractMatrix{<:GridapSolvers.BlockSolvers.SolverBlock}, AbstractVector{<:Gridap.Algebra.LinearSolver}}","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockTriangularSolver","text":"function BlockTriangularSolver(\n  blocks  :: AbstractMatrix{<:SolverBlock},\n  solvers :: AbstractVector{<:LinearSolver},\n  coeffs = fill(1.0,size(blocks)),\n  half   = :upper\n)\n\nCreate and instance of BlockTriangularSolver from its underlying properties. The kwarg half can have values :upper or :lower.\n\n\n\n\n\n","category":"method"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.BlockTriangularSolver-Tuple{AbstractVector{<:Gridap.Algebra.LinearSolver}}","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.BlockTriangularSolver","text":"function BlockTriangularSolver(\n  solvers::AbstractVector{<:LinearSolver}; \n  is_nonlinear::Matrix{Bool}=fill(false,(length(solvers),length(solvers))),\n  coeffs=fill(1.0,size(is_nonlinear)),\n  half=:upper\n)\n\nCreate and instance of BlockTriangularSolver where all blocks are extracted from  the linear system. The kwarg half can have values :upper or :lower.\n\n\n\n\n\n","category":"method"},{"location":"BlockSolvers/#Staggered-FEOperators","page":"BlockSolvers","title":"Staggered FEOperators","text":"","category":"section"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.StaggeredFESolver","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.StaggeredFESolver","text":"struct StaggeredFESolver{NB} <: FESpaces.FESolver\n  solvers :: Vector{<:Union{LinearSolver,NonlinearSolver}}\nend\n\nSolver for staggered problems. See StaggeredFEOperator for more details.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.StaggeredFEOperator","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.StaggeredFEOperator","text":"abstract type StaggeredFEOperator{NB,SB} <: FESpaces.FEOperator end\n\nStaggered operator, used to solve staggered problems. \n\nWe define a staggered problem as a multi-variable non-linear problem where the equation  for the k-th variable u_k only depends on the previous variables u_1,...,u_{k-1} (and itself).\n\nSuch a problem can then be solved by solving each variable sequentially,  using the previous variables as input. The most common examples of staggered problems  are one-directional coupling problems, where the variables are coupled in a chain-like manner.\n\nTwo types of staggered operators are currently supported: \n\nStaggeredAffineFEOperator: when the k-th equation is linear in u_k.\nStaggeredNonlinearFEOperator: when the k-th equation is non-linear in u_k.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.StaggeredAffineFEOperator","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.StaggeredAffineFEOperator","text":"struct StaggeredAffineFEOperator{NB,SB} <: StaggeredFEOperator{NB,SB}\n  ...\nend\n\nAffine staggered operator, used to solve staggered problems  where the k-th equation is linear in u_k.\n\nSuch a problem is formulated by a set of bilinear/linear form pairs:\n\na_k((u_1,...,u_{k-1}),u_k,v_k) = ∫(...)\nl_k((u_1,...,u_{k-1}),v_k) = ∫(...)\n\nthan cam be assembled into a set of linear systems: \n\nA_k u_k = b_k\n\nwhere A_k and b_k only depend on the previous variables u_1,...,u_{k-1}.\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#GridapSolvers.BlockSolvers.StaggeredNonlinearFEOperator","page":"BlockSolvers","title":"GridapSolvers.BlockSolvers.StaggeredNonlinearFEOperator","text":"struct StaggeredNonlinearFEOperator{NB,SB} <: StaggeredFEOperator{NB,SB}\n  ...\nend\n\nNonlinear staggered operator, used to solve staggered problems  where the k-th equation is nonlinear in u_k.\n\nSuch a problem is formulated by a set of residual/jacobian pairs:\n\njac_k((u_1,...,u_{k-1}),u_k,du_k,dv_k) = ∫(...)\nres_k((u_1,...,u_{k-1}),u_k,v_k) = ∫(...)\n\n\n\n\n\n","category":"type"},{"location":"BlockSolvers/#Gridap.Algebra.solve!-Union{Tuple{NB}, Tuple{Any, GridapSolvers.BlockSolvers.StaggeredFESolver{NB}, GridapSolvers.BlockSolvers.StaggeredFEOperator{NB}, Nothing}} where NB","page":"BlockSolvers","title":"Gridap.Algebra.solve!","text":"solve(solver::StaggeredFESolver{NB}, op::StaggeredFEOperator{NB})\nsolve!(xh, solver::StaggeredFESolver{NB}, op::StaggeredFEOperator{NB}, cache::Nothing) where NB\nsolve!(xh, solver::StaggeredFESolver{NB}, op::StaggeredFEOperator{NB}, cache) where NB\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers","text":"","category":"section"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchBasedLinearSolver","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchBasedLinearSolver","text":"struct PatchBasedLinearSolver <: LinearSolver\n  ...\nend\n\nSub-assembled linear solver for patch-based methods. Given a bilinear form a and a space decomposition V = Σ_i V_i given by a patch space, returns a global correction given by aggregated local corrections, i.e \n\ndx = Σ_i w_i I_i inv(A_i) (I_i)^* x \n\nwhere A_i is the patch-local system matrix defined by \n\n(A_i u_i, v_i) = a(u_i,v_i) ∀ v_i ∈ V_i\n\nand I_i is the natural injection from the patch space to the global space. The aggregation can be un-weighted (i.e. w_i = 1) or weighted, where w_i = 1/#(i).\n\n\n\n\n\n","category":"type"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchBasedLinearSolver-Tuple{Function, Gridap.FESpaces.FESpace, Gridap.FESpaces.FESpace}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchBasedLinearSolver","text":"function PatchBasedLinearSolver(\n  biform::Function, \n  patch_space::FESpace, \n  space::FESpace;\n  local_solver = LUSolver(),\n  is_nonlinear = false,\n  weighted = false\n)\n\nReturns an instance of PatchBasedLinearSolver from its underlying properties.   Local patch-systems are solved with local_solver. If weighted, uses weighted    patch aggregation to compute the global correction.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchBoundaryStyle","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchBoundaryStyle","text":"abstract type PatchBoundaryStyle end\nstruct PatchBoundaryExclude  <: PatchBoundaryStyle end\nstruct PatchBoundaryInclude  <: PatchBoundaryStyle end\n\nControls the boundary consitions imposed at the patch boundaries for the sub-spaces.\n\nPatchBoundaryInclude: No BCs are imposed at the patch boundaries. \nPatchBoundaryExclude: Zero dirichlet BCs are imposed at the patch boundaries.\n\n\n\n\n\n","category":"type"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchDecomposition","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchDecomposition","text":"struct PatchDecomposition{Dr,Dc,Dp} <: DiscreteModel{Dc,Dp}\n\nRepresents a patch decomposition of a discrete model, i.e an overlapping cell covering {Ω_i} of Ω such that Ω = Σ_i Ω_i.\n\nProperties:\n\nDr::Integer : Dimension of the patch root\nmodel::DiscreteModel{Dc,Dp} : Underlying discrete model\npatch_cells::Table : [patch][local cell] -> cell\npatch_cells_faces_on_boundary::Table : [d][overlapped cell][local face] -> face is on patch boundary\n\n\n\n\n\n","category":"type"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchDecomposition-Union{Tuple{Gridap.Geometry.DiscreteModel{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchDecomposition","text":"function PatchDecomposition(\n  model::DiscreteModel{Dc,Dp};\n  Dr=0,\n  patch_boundary_style::PatchBoundaryStyle=PatchBoundaryExclude(),\n  boundary_tag_names::AbstractArray{String}=[\"boundary\"]\n)\n\nReturns an instance of PatchDecomposition from a given discrete model.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchFESpace","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchFESpace","text":"struct PatchFESpace <: SingleFieldFESpace\n  ...\nend\n\nFESpace representing a patch-based subspace decomposition V = Σ_i V_i of a global space V.\n\n\n\n\n\n","category":"type"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchFESpace-Tuple{Gridap.FESpaces.FESpace, Any}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchFESpace","text":"function PatchFESpace(\n  space::FESpace,patch_decomposition;kwargs...\n)\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace, PatchDecomposition, Gridap.FESpaces.CellConformity}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchFESpace","text":"function PatchFESpace(\n  space::FESpaces.SingleFieldFESpace,\n  patch_decomposition::PatchDecomposition,\n  cell_conformity::CellConformity;\n  patches_mask=Fill(false,num_patches(patch_decomposition))\n)\n\nConstructs a PatchFESpace from a global SingleFieldFESpace, a PatchDecomposition and a CellConformity instance.\n\nIf patches_mask[p] = true, the patch p is ignored. Used in parallel.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchFESpace-Tuple{Gridap.MultiField.MultiFieldFESpace, PatchDecomposition, Vector{<:Gridap.FESpaces.CellConformity}}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchFESpace","text":"function PatchFESpace(\n  space::Gridap.MultiField.MultiFieldFESpace,\n  patch_decomposition::PatchDecomposition,\n  cell_conformity::Vector{<:CellConformity};\n  kwargs...\n)\n\nPatchFESpace constructor for MultiFieldFESpace.  Returns a MultiFieldFESpace of PatchFESpaces .\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchProlongationOperator","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchProlongationOperator","text":"struct PatchProlongationOperator end\n\nA PatchProlongationOperator is a modified prolongation operator such that given a coarse solution xH returns \n\nxh = Ih(xH) - yh\n\nwhere yh is a subspace-based correction computed by solving local problems on coarse cells  within the fine mesh.\n\n\n\n\n\n","category":"type"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchProlongationOperator-NTuple{5, Any}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchProlongationOperator","text":"function PatchProlongationOperator(\n  lev :: Integer,\n  sh  :: FESpaceHierarchy,\n  PD  :: PatchDecomposition,\n  lhs :: Function,\n  rhs :: Function;\n  is_nonlinear=false\n)\n\nReturns an instance of PatchProlongationOperator for a given level lev and a given  FESpaceHierarchy sh. The subspace-based correction on a solution uH is computed  by solving local problems given by \n\n  lhs(u_i,v_i) = rhs(uH,v_i) ∀ v_i ∈ V_i\n\nwhere V_i is the patch-local space indiced by the PatchDecomposition PD.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.PatchTriangulation","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.PatchTriangulation","text":"struct PatchTriangulation{Dc,Dp} <: Triangulation{Dc,Dp}\n  ...\nend\n\nWrapper around a Triangulation, for patch-based assembly.\n\n\n\n\n\n","category":"type"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.allocate_patch_cell_array-Union{Tuple{T}, Tuple{PatchDecomposition, Gridap.Arrays.Table{T, Vd} where Vd<:AbstractVector{T}}} where T","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.allocate_patch_cell_array","text":"allocate_patch_cell_array(PD::PatchDecomposition,cell_to_data::Table{T};init=zero(T))\n\nAllocates a patch-cell-wise array from a cell-wise array.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.generate_patch_closures-Union{Tuple{PatchDecomposition{Dr, Dc}}, Tuple{Dc}, Tuple{Dr}} where {Dr, Dc}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.generate_patch_closures","text":"generate_patch_closures(PD::PatchDecomposition{Dr,Dc})\n\nReturns a patch-wise Table containing the closure of each patch.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.generate_patch_facets-Union{Tuple{Dp}, Tuple{Dc}, Tuple{Gridap.Geometry.DiscreteModel{Dc, Dp}, Any}} where {Dc, Dp}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.generate_patch_facets","text":"generate_patch_facets(model::DiscreteModel{Dc,Dp},patch_cells)\n\nGiven a model and the cells within each patch, returns a patch-wise Table containing the facets on each patch.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.get_patch_cell_faces-Tuple{PatchDecomposition, Integer}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.get_patch_cell_faces","text":"get_patch_cell_faces(PD::PatchDecomposition,Df::Integer)\nget_patch_cell_faces(PD::PatchDecomposition,Df::Integer,faces_mask::AbstractVector{Bool})\n\nReturns a patch-wise Table containing the faces on each patch cell, i.e \n\npatch_faces[pcell] = [face1, face2, ...]\n\nwhere face1, face2, ... are the faces on the overlapped cell pcell such that \n\nthey are NOT on the boundary of the patch\nthey are flagged true in faces_mask\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.get_patch_cell_offsets-Tuple{PatchDecomposition}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.get_patch_cell_offsets","text":"get_patch_cell_offsets(PD::PatchDecomposition)\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.get_patch_cells-Tuple{PatchDecomposition}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.get_patch_cells","text":"get_patch_cells(PD::PatchDecomposition) -> patch_to_cells\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.get_patch_cells_overlapped-Tuple{PatchDecomposition}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.get_patch_cells_overlapped","text":"get_patch_cells_overlapped(PD::PatchDecomposition) -> patch_to_pcells\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.get_patch_faces-Union{Tuple{Dc}, Tuple{Dr}, Tuple{PatchDecomposition{Dr, Dc}, Integer, AbstractVector{Bool}}} where {Dr, Dc}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.get_patch_faces","text":"get_patch_faces(PD::PatchDecomposition,Df::Integer,faces_mask::AbstractVector{Bool};reverse=false)\n\nReturns a patch-wise Table containing the faces on each patch, i.e \n\npatch_faces[patch] = [face1, face2, ...]\n\nwhere face1, face2, ... are the faces on the patch such that \n\nthey are NOT on the boundary of the patch\nthey are flagged true in faces_mask\n\nIf reverse is true, the faces are the ones ON the boundary of the patch.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.get_pface_to_pcell-Union{Tuple{Dc}, Tuple{Dr}, Tuple{PatchDecomposition{Dr, Dc}, Integer, Any}} where {Dr, Dc}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.get_pface_to_pcell","text":"get_pface_to_pcell(PD::PatchDecomposition{Dr,Dc},Df::Integer,patch_faces)\n\nReturns two pface-wise Tables containing \n\nthe patch cells touched by each patch face and \nthe local cell index (within the face connectivity) of the cell touched by the patch face, which is needed when a pface touches different cells depending on the patch\n\ni.e\n\npface_to_pcell[pface] = [pcell1, pcell2, ...]\npface_to_lcell[pface] = [lcell1, lcell2, ...]\n\nwhere pcell1, pcell2, ... are the patch cells touched by the patch face pface.\n\nThis would be the Gridap equivalent to get_faces(patch_topology,Df,Dc).\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.num_patches-Tuple{PatchDecomposition}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.num_patches","text":"num_patches(a::PatchDecomposition)\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.patch_reindex-Tuple{PatchDecomposition, Any}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.patch_reindex","text":"patch_reindex(PD::PatchDecomposition,cell_to_data) -> pcell_to_data\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.patch_view-Tuple{PatchDecomposition, AbstractArray, Integer}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.patch_view","text":"patch_view(PD::PatchDecomposition,a::AbstractArray,patch::Integer)\npatch_view(PD::PatchDecomposition,a::AbstractArray,patch_ids::AbstractUnitRange{<:Integer})\n\nReturns a view of the pcell-wise array a restricted to the pcells of the patch patch or patch_ids.\n\n\n\n\n\n","category":"method"},{"location":"PatchBasedSmoothers/#GridapSolvers.PatchBasedSmoothers.propagate_patch_dof_ids-Tuple{PatchFESpace, Gridap.Arrays.Table}","page":"PatchBasedSmoothers","title":"GridapSolvers.PatchBasedSmoothers.propagate_patch_dof_ids","text":"propagate_patch_dof_ids(patch_space::PatchFESpace,new_patch_cells::Table)\n\nPropagates the DoF ids of the patchspace to a new set of patch cells given by  a patch-wise Table `newpatch_cells`.\n\n\n\n\n\n","category":"method"},{"location":"Examples/StokesGMG/#Incompressible-Stokes-equations-in-a-2D/3D-cavity,-using-GMG.","page":"Stokes (GMG)","title":"Incompressible Stokes equations in a 2D/3D cavity, using GMG.","text":"","category":"section"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"This example solves the incompressible Stokes equations, given by","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"beginalign*\n-Delta u - nabla p = f quad textin quad Omega \nnabla cdot u = 0 quad textin quad Omega \nu = hatx quad textin quad Gamma_texttop subset partial Omega \nu = 0 quad textin quad partial Omega backslash Gamma_texttop \nendalign*","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"where Omega = 01^d.","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"We use a mixed finite-element scheme, with Q_k times P_k-1^- elements for the velocity-pressure pair.","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"To solve the linear system, we use a FGMRES solver preconditioned by a block-triangular Shur-complement-based preconditioner. We use an Augmented Lagrangian approach to get a better approximation of the Schur complement. Details for this preconditoner can be found in Benzi and Olshanskii (2006).","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"The velocity block is solved using a Geometric Multigrid (GMG) solver. Due to the kernel introduced by the Augmented-Lagrangian operator, we require special smoothers and prolongation/restriction operators. See Schoberl (1999) for more details.","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"module StokesGMGApplication\n\nusing Test\nusing LinearAlgebra\nusing FillArrays, BlockArrays\n\nusing Gridap\nusing Gridap.ReferenceFEs, Gridap.Algebra, Gridap.Geometry, Gridap.FESpaces\nusing Gridap.CellData, Gridap.MultiField, Gridap.Algebra\nusing PartitionedArrays\nusing GridapDistributed\n\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers, GridapSolvers.MultilevelTools, GridapSolvers.PatchBasedSmoothers\nusing GridapSolvers.BlockSolvers: LinearSystemBlock, BiformBlock, BlockTriangularSolver\n\nfunction get_patch_smoothers(mh,tests,biform,patch_decompositions,qdegree)\n  patch_spaces = PatchFESpace(tests,patch_decompositions)\n  nlevs = num_levels(mh)\n  smoothers = map(view(tests,1:nlevs-1),patch_decompositions,patch_spaces) do tests, PD, Ph\n    Vh = get_fe_space(tests)\n    Ω  = Triangulation(PD)\n    dΩ = Measure(Ω,qdegree)\n    ap = (u,v) -> biform(u,v,dΩ)\n    patch_smoother = PatchBasedLinearSolver(ap,Ph,Vh)\n    return RichardsonSmoother(patch_smoother,10,0.2)\n  end\n  return smoothers\nend\n\nfunction get_bilinear_form(mh_lev,biform,qdegree)\n  model = get_model(mh_lev)\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n  return (u,v) -> biform(u,v,dΩ)\nend\n\nfunction add_labels_2d!(labels)\n  add_tag_from_tags!(labels,\"top\",[6])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,7,8])\nend\n\nfunction add_labels_3d!(labels)\n  add_tag_from_tags!(labels,\"top\",[22])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26])\nend\n\nfunction main(distribute,np,nc,np_per_level)\n  parts = distribute(LinearIndices((prod(np),)))\n\n  Dc = length(nc)\n  domain = (Dc == 2) ? (0,1,0,1) : (0,1,0,1,0,1)\n  add_labels! = (Dc == 2) ? add_labels_2d! : add_labels_3d!\n  mh = CartesianModelHierarchy(parts,np_per_level,domain,nc;add_labels! = add_labels!)\n  model = get_model(mh,1)\n\n  order = 2\n  qdegree = 2*(order+1)\n  reffe_u = ReferenceFE(lagrangian,VectorValue{Dc,Float64},order)\n  reffe_p = ReferenceFE(lagrangian,Float64,order-1;space=:P)\n\n  u_walls = (Dc==2) ? VectorValue(0.0,0.0) : VectorValue(0.0,0.0,0.0)\n  u_top = (Dc==2) ? VectorValue(1.0,0.0) : VectorValue(1.0,0.0,0.0)\n\n  tests_u  = TestFESpace(mh,reffe_u,dirichlet_tags=[\"walls\",\"top\"]);\n  trials_u = TrialFESpace(tests_u,[u_walls,u_top]);\n  U, V = get_fe_space(trials_u,1), get_fe_space(tests_u,1)\n  Q = TestFESpace(model,reffe_p;conformity=:L2,constraint=:zeromean)\n\n  mfs = Gridap.MultiField.BlockMultiFieldStyle()\n  X = MultiFieldFESpace([U,Q];style=mfs)\n  Y = MultiFieldFESpace([V,Q];style=mfs)\n\n  α = 1.e2\n  f = (Dc==2) ? VectorValue(1.0,1.0) : VectorValue(1.0,1.0,1.0)\n  Π_Qh = LocalProjectionMap(divergence,reffe_p,qdegree)\n  graddiv(u,v,dΩ) = ∫(α*(∇⋅v)⋅Π_Qh(u))dΩ\n  biform_u(u,v,dΩ) = ∫(∇(v)⊙∇(u))dΩ + graddiv(u,v,dΩ)\n  biform((u,p),(v,q),dΩ) = biform_u(u,v,dΩ) - ∫(divergence(v)*p)dΩ - ∫(divergence(u)*q)dΩ\n  liform((v,q),dΩ) = ∫(v⋅f)dΩ\n\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n\n  a(u,v) = biform(u,v,dΩ)\n  l(v) = liform(v,dΩ)\n  op = AffineFEOperator(a,l,X,Y)\n  A, b = get_matrix(op), get_vector(op);\n\n  biforms = map(mhl -> get_bilinear_form(mhl,biform_u,qdegree),mh)\n  patch_decompositions = PatchDecomposition(mh)\n  smoothers = get_patch_smoothers(\n    mh,tests_u,biform_u,patch_decompositions,qdegree\n  )\n  prolongations = setup_patch_prolongation_operators(\n    tests_u,biform_u,graddiv,qdegree\n  )\n  restrictions = setup_patch_restriction_operators(\n    tests_u,prolongations,graddiv,qdegree;solver=CGSolver(JacobiLinearSolver())\n  )\n  gmg = GMGLinearSolver(\n    trials_u,tests_u,biforms,\n    prolongations,restrictions,\n    pre_smoothers=smoothers,\n    post_smoothers=smoothers,\n    coarsest_solver=LUSolver(),\n    maxiter=4,mode=:preconditioner,verbose=i_am_main(parts)\n  )\n\n  solver_u = gmg\n  solver_p = CGSolver(JacobiLinearSolver();maxiter=20,atol=1e-14,rtol=1.e-6,verbose=i_am_main(parts))\n  solver_u.log.depth = 2\n  solver_p.log.depth = 2\n\n  diag_blocks  = [LinearSystemBlock(),BiformBlock((p,q) -> ∫(-1.0/α*p*q)dΩ,Q,Q)]\n  bblocks = map(CartesianIndices((2,2))) do I\n    (I[1] == I[2]) ? diag_blocks[I[1]] : LinearSystemBlock()\n  end\n  coeffs = [1.0 1.0;\n            0.0 1.0]\n  P = BlockTriangularSolver(bblocks,[solver_u,solver_p],coeffs,:upper)\n  solver = FGMRESSolver(20,P;atol=1e-10,rtol=1.e-12,verbose=i_am_main(parts))\n  ns = numerical_setup(symbolic_setup(solver,A),A)\n\n  x = allocate_in_domain(A); fill!(x,0.0)\n  solve!(x,ns,b)\n  xh = FEFunction(X,x);\n\n  r = allocate_in_range(A)\n  mul!(r,A,x)\n  r .-= b\n  @test norm(r) < 1.e-7\nend\n\nend # module","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"","category":"page"},{"location":"Examples/StokesGMG/","page":"Stokes (GMG)","title":"Stokes (GMG)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Extensions/IterativeSolvers/#IterativeSolvers.jl-extension","page":"IterativeSolvers.jl","title":"IterativeSolvers.jl extension","text":"","category":"section"},{"location":"Extensions/IterativeSolvers/","page":"IterativeSolvers.jl","title":"IterativeSolvers.jl","text":"GridapSolvers provides wrappers for some iterative solvers from the package IterativeSolvers.jl:","category":"page"},{"location":"Extensions/IterativeSolvers/#IterativeSolversExt.IterativeLinearSolver","page":"IterativeSolvers.jl","title":"IterativeSolversExt.IterativeLinearSolver","text":"struct IterativeLinearSolver <: LinearSolver\n  ...\nend\n\nWrappers for IterativeSolvers.jl   krylov-like iterative solvers.\n\nAll wrappers take the same kwargs as the corresponding solver in IterativeSolvers.jl.\n\nThe following solvers are available:\n\nIS_ConjugateGradientSolver\nIS_GMRESSolver\nIS_MINRESSolver\nIS_SSORSolver\n\n\n\n\n\n","category":"type"},{"location":"Extensions/IterativeSolvers/#GridapSolvers.IS_ConjugateGradientSolver","page":"IterativeSolvers.jl","title":"GridapSolvers.IS_ConjugateGradientSolver","text":"IS_ConjugateGradientSolver(;kwargs...)\n\nWrapper for the Conjugate Gradient solver.\n\n\n\n\n\n","category":"function"},{"location":"Extensions/IterativeSolvers/#GridapSolvers.IS_GMRESSolver","page":"IterativeSolvers.jl","title":"GridapSolvers.IS_GMRESSolver","text":"IS_GMRESSolver(;kwargs...)\n\nWrapper for the GMRES solver.\n\n\n\n\n\n","category":"function"},{"location":"Extensions/IterativeSolvers/#GridapSolvers.IS_MINRESSolver","page":"IterativeSolvers.jl","title":"GridapSolvers.IS_MINRESSolver","text":"IS_MINRESSolver(;kwargs...)\n\nWrapper for the MINRES solver.\n\n\n\n\n\n","category":"function"},{"location":"Extensions/IterativeSolvers/#GridapSolvers.IS_SSORSolver","page":"IterativeSolvers.jl","title":"GridapSolvers.IS_SSORSolver","text":"IS_SSORSolver(ω;kwargs...)\n\nWrapper for the SSOR solver.\n\n\n\n\n\n","category":"function"},{"location":"Extensions/GridapP4est/#GridapP4est.jl-extension","page":"GridapP4est.jl","title":"GridapP4est.jl extension","text":"","category":"section"},{"location":"Extensions/GridapP4est/","page":"GridapP4est.jl","title":"GridapP4est.jl","text":"Building on top of GridapP4est.jl, GridapSolvers provides tools to use the P4est library to build DiscreteModelHierarchy objects.","category":"page"},{"location":"Extensions/GridapP4est/#GridapSolvers.P4estCartesianModelHierarchy","page":"GridapP4est.jl","title":"GridapSolvers.P4estCartesianModelHierarchy","text":"P4estCartesianModelHierarchy(\n  ranks,np_per_level,domain,nc;\n  num_refs_coarse::Integer = 0,\n  add_labels!::Function = (labels -> nothing),\n  map::Function = identity,\n  isperiodic = Tuple(fill(false,length(nc)))\n)\n\nReturns a ModelHierarchy with a Cartesian model as coarsest level, using GridapP4est.jl.    The i-th level will be distributed among np_per_level[i] processors.    The seed model is given by cmodel = CartesianDiscreteModel(domain,nc).\n\n\n\n\n\n","category":"function"},{"location":"Extensions/GridapP4est/#Examples-of-usage","page":"GridapP4est.jl","title":"Examples of usage","text":"","category":"section"},{"location":"Extensions/GridapP4est/","page":"GridapP4est.jl","title":"GridapP4est.jl","text":"# Start from a coarse mesh, then refine\nfunction p4est_mesh_by_refinement(distribute,np_per_level,domain,nc;nrefs=0)\n  GridapP4est.with(parts) do\n    parts  = distribute(LinearIndices((np_per_level[1],)))\n    cparts = generate_subparts(parts,np_per_level[end])\n    base   = CartesianDiscreteModel(domain,nc)\n    cmodel = OctreeDistributedDiscreteModel(cparts,base,nrefs)\n    return ModelHierarchy(parts,cmodel,np_per_level)\n  end\nend\n\n# Start from a fine mesh, then coarsen\nfunction p4est_mesh_by_coarsening(distribute,np_per_level,domain,nc;nrefs=0)\n  GridapP4est.with(parts) do\n    n_levs = length(np_per_level)\n    fparts = distribute(LinearIndices((np_per_level[1],)))\n    base   = CartesianDiscreteModel(domain,nc)\n    fmodel = OctreeDistributedDiscreteModel(fparts,base,nrefs+n_levs)\n    return ModelHierarchy(parts,fmodel,np_per_level)\n  end\nend","category":"page"},{"location":"Examples/Stokes/#Incompressible-Stokes-equations-in-a-2D/3D-cavity","page":"Stokes","title":"Incompressible Stokes equations in a 2D/3D cavity","text":"","category":"section"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"This example solves the incompressible Stokes equations, given by","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"beginalign*\n-Delta u - nabla p = f quad textin quad Omega \nnabla cdot u = 0 quad textin quad Omega \nu = hatx quad textin quad Gamma_texttop subset partial Omega \nu = 0 quad textin quad partial Omega backslash Gamma_texttop \nendalign*","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"where Omega = 01^d.","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"We use a mixed finite-element scheme, with Q_k times P_k-1^- elements for the velocity-pressure pair.","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"To solve the linear system, we use a FGMRES solver preconditioned by a block-triangular Shur-complement-based preconditioner. We use an Augmented Lagrangian approach to get a better approximation of the Schur complement. Details for this preconditoner can be found in Benzi and Olshanskii (2006).","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"The velocity block is solved directly using an exact solver.","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"module StokesApplication\n\nusing Test\nusing LinearAlgebra\nusing FillArrays, BlockArrays\n\nusing Gridap\nusing Gridap.ReferenceFEs, Gridap.Algebra, Gridap.Geometry, Gridap.FESpaces\nusing Gridap.CellData, Gridap.MultiField, Gridap.Algebra\nusing PartitionedArrays\nusing GridapDistributed\n\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers, GridapSolvers.MultilevelTools\nusing GridapSolvers.BlockSolvers: LinearSystemBlock, BiformBlock, BlockTriangularSolver\n\nfunction add_labels_2d!(labels)\n  add_tag_from_tags!(labels,\"top\",[6])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,7,8])\nend\n\nfunction add_labels_3d!(labels)\n  add_tag_from_tags!(labels,\"top\",[22])\n  add_tag_from_tags!(labels,\"walls\",[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26])\nend\n\nfunction main(distribute,np,nc)\n  parts = distribute(LinearIndices((prod(np),)))\n\n  Dc = length(nc)\n  domain = (Dc == 2) ? (0,1,0,1) : (0,1,0,1,0,1)\n\n  model = CartesianDiscreteModel(parts,np,domain,nc)\n  add_labels! = (Dc == 2) ? add_labels_2d! : add_labels_3d!\n  add_labels!(get_face_labeling(model))\n\n  order = 2\n  qdegree = 2*(order+1)\n  reffe_u = ReferenceFE(lagrangian,VectorValue{Dc,Float64},order)\n  reffe_p = ReferenceFE(lagrangian,Float64,order-1;space=:P)\n\n  u_walls = (Dc==2) ? VectorValue(0.0,0.0) : VectorValue(0.0,0.0,0.0)\n  u_top = (Dc==2) ? VectorValue(1.0,0.0) : VectorValue(1.0,0.0,0.0)\n\n  V = TestFESpace(model,reffe_u,dirichlet_tags=[\"walls\",\"top\"]);\n  U = TrialFESpace(V,[u_walls,u_top]);\n  Q = TestFESpace(model,reffe_p;conformity=:L2,constraint=:zeromean)\n\n  mfs = Gridap.MultiField.BlockMultiFieldStyle()\n  X = MultiFieldFESpace([U,Q];style=mfs)\n  Y = MultiFieldFESpace([V,Q];style=mfs)\n\n  α = 1.e2\n  f = (Dc==2) ? VectorValue(1.0,1.0) : VectorValue(1.0,1.0,1.0)\n  Π_Qh = LocalProjectionMap(divergence,Q,qdegree)\n  graddiv(u,v,dΩ)  = ∫(α*(∇⋅v)⋅Π_Qh(u))dΩ\n  biform_u(u,v,dΩ) = ∫(∇(v)⊙∇(u))dΩ + graddiv(u,v,dΩ)\n  biform((u,p),(v,q),dΩ) = biform_u(u,v,dΩ) - ∫(divergence(v)*p)dΩ - ∫(divergence(u)*q)dΩ\n  liform((v,q),dΩ) = ∫(v⋅f)dΩ\n\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n\n  a(u,v) = biform(u,v,dΩ)\n  l(v) = liform(v,dΩ)\n  op = AffineFEOperator(a,l,X,Y)\n  A, b = get_matrix(op), get_vector(op);\n\n  solver_u = LUSolver()\n  solver_p = CGSolver(JacobiLinearSolver();maxiter=20,atol=1e-14,rtol=1.e-6)\n  solver_p.log.depth = 2\n\n  bblocks = [LinearSystemBlock() LinearSystemBlock();\n             LinearSystemBlock() BiformBlock((p,q) -> ∫(-(1.0/α)*p*q)dΩ,Q,Q)]\n  coeffs = [1.0 1.0;\n            0.0 1.0]\n  P = BlockTriangularSolver(bblocks,[solver_u,solver_p],coeffs,:upper)\n  solver = FGMRESSolver(20,P;atol=1e-10,rtol=1.e-12,verbose=i_am_main(parts))\n  ns = numerical_setup(symbolic_setup(solver,A),A)\n\n  x = allocate_in_domain(A); fill!(x,0.0)\n  solve!(x,ns,b)\n\n  r = allocate_in_range(A)\n  mul!(r,A,x)\n  r .-= b\n  @test norm(r) < 1.e-7\nend\n\nend # module","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"","category":"page"},{"location":"Examples/Stokes/","page":"Stokes","title":"Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers","text":"","category":"section"},{"location":"LinearSolvers/#Krylov-solvers","page":"LinearSolvers","title":"Krylov solvers","text":"","category":"section"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.CGSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.CGSolver","text":"struct CGSolver <: LinearSolver\n  ...\nend\n\nCGSolver(Pl;maxiter=1000,atol=1e-12,rtol=1.e-6,flexible=false,verbose=0,name=\"CG\")\n\nLeft-Preconditioned Conjugate Gradient solver.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.MINRESSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.MINRESSolver","text":"struct MINRESSolver <: LinearSolver \n  ...\nend\n\nMINRESSolver(m;Pl=nothing,maxiter=100,atol=1e-12,rtol=1.e-6,verbose=false,name=\"MINRES\")\n\nMINRES solver, with optional left preconditioners Pl. The preconditioner must be    symmetric and positive definite.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.GMRESSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.GMRESSolver","text":"struct GMRESSolver <: LinearSolver \n  ...\nend\n\nGMRESSolver(m;Pr=nothing,Pl=nothing,restart=false,m_add=1,maxiter=100,atol=1e-12,rtol=1.e-6,verbose=false,name=\"GMRES\")\n\nGMRES solver, with optional right and left preconditioners Pr and Pl.\n\nThe solver starts by allocating a basis of size m. Then: \n\nIf restart=true, the basis size is fixed and restarted every m iterations.\nIf restart=false, the basis size is allowed to increase. When full, the solver  allocates m_add new basis vectors.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.FGMRESSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.FGMRESSolver","text":"struct FGMRESSolver <: LinearSolver \n  ...\nend\n\nFGMRESSolver(m,Pr;Pl=nothing,restart=false,m_add=1,maxiter=100,atol=1e-12,rtol=1.e-6,verbose=false,name=\"FGMRES\")\n\nFlexible GMRES solver, with right-preconditioner Pr and optional left-preconditioner Pl.\n\nThe solver starts by allocating a basis of size m. Then: \n\nIf restart=true, the basis size is fixed and restarted every m iterations.\nIf restart=false, the basis size is allowed to increase. When full, the solver  allocates m_add new basis vectors at a time.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.krylov_mul!","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.krylov_mul!","text":"Computes the Krylov matrix-vector product \n\ny = Pl⁻¹⋅A⋅Pr⁻¹⋅x\n\nby solving\n\nPr⋅wr = x     wl = A⋅wr     Pl⋅y = wl\n\n\n\n\n\n","category":"function"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.krylov_residual!","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.krylov_residual!","text":"Computes the Krylov residual \n\nr = Pl⁻¹(A⋅x - b)\n\nby solving\n\nw = A⋅x - b     Pl⋅r = w\n\n\n\n\n\n","category":"function"},{"location":"LinearSolvers/#Richardson-iterative-solver","page":"LinearSolvers","title":"Richardson iterative solver","text":"","category":"section"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"Given a linear system Ax = b and a left preconditioner Pl, this iterative solver performs the following iteration until the solution converges.","category":"page"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"  x_k+1 = x_k + omega Pl^-1 (b - A x_k)","category":"page"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.RichardsonLinearSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.RichardsonLinearSolver","text":"struct RichardsonLinearSolver <: LinearSolver \n  ...\nend\n\nRichardsonLinearSolver(ω,maxiter;Pl=nothing,rtol=1e-10,atol=1e-6,verbose=true,name = \"RichardsonLinearSolver\")\n\nRichardson Iteration, with an optional left preconditioners Pl.\n\nThe relaxation parameter (ω) can either be of type Float64 or Vector{Float64}.    This gives flexiblity in relaxation.  \n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#Smoothers","page":"LinearSolvers","title":"Smoothers","text":"","category":"section"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"Given a linear system Ax = b, a smoother is an operator S that takes an iterative solution x_k and its residual r_k = b - A x_k, and modifies them in place","category":"page"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"  S  (x_kr_k) rightarrow (x_k+1r_k+1)","category":"page"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"such that r_k+1  r_k.","category":"page"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.RichardsonSmoother","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.RichardsonSmoother","text":"struct RichardsonSmoother{A} <: LinearSolver\n  M     :: A\n  niter :: Int64\n  ω     :: Float64\nend\n\nIterative Richardson smoother. Given a solution x and a residual r, performs niter Richardson iterations with damping parameter ω using the linear solver M.  A Richardson iteration is given by:\n\ndx = ω * inv(M) * r\nx  = x + dx\nr  = r - A * dx\n\nUpdates both the solution x and the residual r in place.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.RichardsonSmoother-Tuple{Gridap.Algebra.LinearSolver}","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.RichardsonSmoother","text":"function RichardsonSmoother(M::LinearSolver,niter::Int=1,ω::Float64=1.0)\n\nReturns an instance of RichardsonSmoother from its underlying properties.\n\n\n\n\n\n","category":"method"},{"location":"LinearSolvers/#Preconditioners","page":"LinearSolvers","title":"Preconditioners","text":"","category":"section"},{"location":"LinearSolvers/","page":"LinearSolvers","title":"LinearSolvers","text":"Given a linear system Ax = b, a preconditioner is an operator that takes an iterative residual r_k and returns a correction dx_k.","category":"page"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.JacobiLinearSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.JacobiLinearSolver","text":"struct JacobiLinearSolver <: LinearSolver end\n\nGiven a matrix A, the Jacobi or Diagonal preconditioner is defined as P = diag(A).\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.GMGLinearSolverFromMatrices","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.GMGLinearSolverFromMatrices","text":"struct GMGLinearSolverFromMatrices <: LinearSolver\n  ...\nend\n\nGeometric MultiGrid solver, from algebraic parts.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.GMGLinearSolverFromWeakform","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.GMGLinearSolverFromWeakform","text":"struct GMGLinearSolverFromWeakForm <: LinearSolver\n  ...\nend\n\nGeometric MultiGrid solver, from FE parts.\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.GMGLinearSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.GMGLinearSolver","text":"GMGLinearSolver(\n  matrices::AbstractArray{<:AbstractMatrix},\n  prolongations,\n  restrictions;\n  pre_smoothers   = Fill(RichardsonSmoother(JacobiLinearSolver(),10),num_levels(mh)-1),\n  post_smoothers  = pre_smoothers,\n  coarsest_solver = LUSolver(),\n  mode::Symbol    = :preconditioner,\n  maxiter = 100, atol = 1.0e-14, rtol = 1.0e-08, verbose = false,\n)\n\nCreates an instance of GMGLinearSolverFromMatrices from the underlying model  hierarchy, the system matrices at each level and the transfer operators and smoothers  at each level except the coarsest.\n\nThe solver has two modes of operation, defined by the kwarg mode:\n\n:solver: The GMG solver takes a rhs b and returns a solution x.\n:preconditioner: The GMG solver takes a residual r and returns a correction dx.\n\n\n\n\n\nGMGLinearSolver(\n  trials::FESpaceHierarchy,\n  tests::FESpaceHierarchy,\n  biforms::AbstractArray{<:Function},\n  interp,\n  restrict;\n  pre_smoothers   = Fill(RichardsonSmoother(JacobiLinearSolver(),10),num_levels(mh)-1),\n  post_smoothers  = pre_smoothers,\n  coarsest_solver = Gridap.Algebra.LUSolver(),\n  mode::Symbol    = :preconditioner,\n  is_nonlinear    = false,\n  maxiter = 100, atol = 1.0e-14, rtol = 1.0e-08, verbose = false,\n)\n\nCreates an instance of GMGLinearSolverFromMatrices from the underlying model  hierarchy, the trial and test FEspace hierarchies, the weakform lhs at each level  and the transfer operators and smoothers at each level except the coarsest.\n\nThe solver has two modes of operation, defined by the kwarg mode:\n\n:solver: The GMG solver takes a rhs b and returns a solution x.\n:preconditioner: The GMG solver takes a residual r and returns a correction dx.\n\n\n\n\n\n","category":"function"},{"location":"LinearSolvers/#Other","page":"LinearSolvers","title":"Other","text":"","category":"section"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.NullspaceSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.NullspaceSolver","text":"struct NullspaceSolver{A,B}\n  solver :: A <: LinearSolver\n  kernel :: B <: Union{AbstractMatrix, Vector{<:AbstractVector}}\n  constrain_matrix :: Bool = true\nend\n\nSolver that computes the solution of a linear system A⋅x = b with a kernel constraint, i.e the returned solution is orthogonal to the provided kernel.\n\nWe assume the kernel is provided as a matrix K of dimensions (k,n) with n the dimension of the original system and k the number of kernel vectors.\n\nTwo modes of operation are supported:\n\nIf constrain_matrix is true, the solver will explicitly constrain the system matrix.  I.e we consider the augmented system Â⋅x̂ = b̂ where\nAk = [A, K'; K, 0]\nx̂ = [x; λ]\nb̂ = [b; 0]\nThis is often the only option for direct solvers, which require the system matrix to be invertible. This is only supported in serial (its performance bottleneck in parallel).\nIf constrain_matrix is false, the solver preserve the original system and simply  project the initial guess and the solution onto the orthogonal complement of the kernel.  This option is more suitable for iterative solvers, which usually do not require the  system matrix to be invertible (e.g. GMRES, BiCGStab, etc).\n\n\n\n\n\n","category":"type"},{"location":"LinearSolvers/#GridapSolvers.LinearSolvers.CallbackSolver","page":"LinearSolvers","title":"GridapSolvers.LinearSolvers.CallbackSolver","text":"CallbackSolver(solver::LinearSolver,callback::Function)\n\nA linear solver that runs a callback function after solving the linear system. The callback function should take the solution vector as its only argument and return nothing, i.e  callback(x::AbstractVector) -> nothing.\n\nThis structure is useful to add functionality to any linear solver, such as: \n\nLogging the solution, residuals, etc.\nMonitoring properties of the solution, as it's divergence or mean. \nModifying the solution in-place after solving the linear system, to apply a correction,  for example.\n\n\n\n\n\n","category":"type"},{"location":"Examples/DarcyGMG/","page":"Darcy (GMG)","title":"Darcy (GMG)","text":"module DarcyGMGApplication\n\nusing Test\nusing LinearAlgebra\nusing FillArrays, BlockArrays\n\nusing Gridap\nusing Gridap.ReferenceFEs, Gridap.Algebra, Gridap.Geometry, Gridap.FESpaces\nusing Gridap.CellData, Gridap.MultiField, Gridap.Algebra\nusing PartitionedArrays\nusing GridapDistributed\n\nusing GridapSolvers\nusing GridapSolvers.LinearSolvers, GridapSolvers.MultilevelTools, GridapSolvers.PatchBasedSmoothers\nusing GridapSolvers.BlockSolvers: LinearSystemBlock, BiformBlock, BlockTriangularSolver\n\nfunction get_patch_smoothers(mh,tests,biform,patch_decompositions,qdegree)\n  patch_spaces = PatchFESpace(tests,patch_decompositions)\n  nlevs = num_levels(mh)\n  smoothers = map(view(tests,1:nlevs-1),patch_decompositions,patch_spaces) do tests, PD, Ph\n    Vh = get_fe_space(tests)\n    Ω  = Triangulation(PD)\n    dΩ = Measure(Ω,qdegree)\n    ap = (u,v) -> biform(u,v,dΩ)\n    patch_smoother = PatchBasedLinearSolver(ap,Ph,Vh)\n    return RichardsonSmoother(patch_smoother,10,0.2)\n  end\n  return smoothers\nend\n\nfunction get_bilinear_form(mh_lev,biform,qdegree)\n  model = get_model(mh_lev)\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n  return (u,v) -> biform(u,v,dΩ)\nend\n\nfunction main(distribute,np,nc,np_per_level)\n  parts = distribute(LinearIndices((prod(np),)))\n\n  Dc = length(nc)\n  domain = (Dc == 2) ? (0,1,0,1) : (0,1,0,1,0,1)\n  mh = CartesianModelHierarchy(parts,np_per_level,domain,nc)\n  model = get_model(mh,1)\n\n  order = 2\n  qdegree = 2*(order+1)\n  reffe_u = ReferenceFE(raviart_thomas,Float64,order-1)\n  reffe_p = ReferenceFE(lagrangian,Float64,order-1;space=:P)\n\n  u_exact(x) = (Dc==2) ? VectorValue(x[1]+x[2],-x[2]) : VectorValue(x[1]+x[2],-x[2],0.0)\n  p_exact(x) = 2.0*x[1]-1.0\n\n  tests_u  = TestFESpace(mh,reffe_u,dirichlet_tags=[\"boundary\"]);\n  trials_u = TrialFESpace(tests_u,[u_exact]);\n  U, V = get_fe_space(trials_u,1), get_fe_space(tests_u,1)\n  Q = TestFESpace(model,reffe_p;conformity=:L2)\n\n  mfs = Gridap.MultiField.BlockMultiFieldStyle()\n  X = MultiFieldFESpace([U,Q];style=mfs)\n  Y = MultiFieldFESpace([V,Q];style=mfs)\n\n  α = 1.e2\n  f(x) = u_exact(x) + ∇(p_exact)(x)\n  graddiv(u,v,dΩ) = ∫(α*divergence(u)⋅divergence(v))dΩ\n  biform_u(u,v,dΩ) = ∫(v⊙u)dΩ + graddiv(u,v,dΩ)\n  biform((u,p),(v,q),dΩ) = biform_u(u,v,dΩ) - ∫(divergence(v)*p)dΩ - ∫(divergence(u)*q)dΩ\n  liform((v,q),dΩ) = ∫(v⋅f)dΩ\n\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,qdegree)\n\n  a(u,v) = biform(u,v,dΩ)\n  l(v) = liform(v,dΩ)\n  op = AffineFEOperator(a,l,X,Y)\n  A, b = get_matrix(op), get_vector(op);\n\n  biforms = map(mhl -> get_bilinear_form(mhl,biform_u,qdegree),mh)\n  patch_decompositions = PatchDecomposition(mh)\n  smoothers = get_patch_smoothers(\n    mh,tests_u,biform_u,patch_decompositions,qdegree\n  )\n  prolongations = setup_prolongation_operators(\n    tests_u,qdegree;mode=:residual\n  )\n  restrictions = setup_restriction_operators(\n    tests_u,qdegree;mode=:residual,solver=CGSolver(JacobiLinearSolver())\n  )\n\n  gmg = GMGLinearSolver(\n    trials_u,tests_u,biforms,\n    prolongations,restrictions,\n    pre_smoothers=smoothers,\n    post_smoothers=smoothers,\n    coarsest_solver=LUSolver(),\n    maxiter=3,mode=:preconditioner,verbose=i_am_main(parts)\n  )\n\n  solver_u = gmg\n  solver_p = CGSolver(JacobiLinearSolver();maxiter=20,atol=1e-14,rtol=1.e-6,verbose=i_am_main(parts))\n  solver_p.log.depth = 2\n\n  bblocks  = [LinearSystemBlock() LinearSystemBlock();\n              LinearSystemBlock() BiformBlock((p,q) -> ∫(-1.0/α*p*q)dΩ,Q,Q)]\n  coeffs = [1.0 1.0;\n            0.0 1.0]\n  P = BlockTriangularSolver(bblocks,[solver_u,solver_p],coeffs,:upper)\n  solver = FGMRESSolver(20,P;atol=1e-14,rtol=1.e-10,verbose=i_am_main(parts))\n  ns = numerical_setup(symbolic_setup(solver,A),A)\n\n  x = allocate_in_domain(A); fill!(x,0.0)\n  solve!(x,ns,b)\n\n  r = allocate_in_range(A)\n  mul!(r,A,x)\n  r .-= b\n  @test norm(r) < 1.e-5\nend\n\nend # module","category":"page"},{"location":"Examples/DarcyGMG/","page":"Darcy (GMG)","title":"Darcy (GMG)","text":"","category":"page"},{"location":"Examples/DarcyGMG/","page":"Darcy (GMG)","title":"Darcy (GMG)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"Examples/Elasticity/","page":"-","title":"-","text":"using Gridap\nusing Gridap.Geometry, Gridap.Algebra\n\nusing PartitionedArrays\nusing GridapDistributed\nusing GridapPETSc\n\nusing GridapSolvers\n\nfunction main(distribute,np)\n  ranks = distribute(LinearIndices((prod(np),)))\n  model = CartesianDiscreteModel(ranks,np,(0,1,0,1),(20,20))\n\n  labels = get_face_labeling(model)\n  add_tag_from_tags!(labels,\"diri_0\",[1,3,7])\n  add_tag_from_tags!(labels,\"diri_1\",[2,4,8])\n\n  order = 1\n  reffe = ReferenceFE(lagrangian,VectorValue{2,Float64},order)\n  V = TestFESpace(model,reffe,dirichlet_tags=[\"diri_0\", \"diri_1\"])\n\n  disp_x = 0.5\n  g0 = VectorValue(0.0,0.0)\n  g1 = VectorValue(disp_x,0.0)\n  U = TrialFESpace(V,[g0,g1])\n\n  λ = 100.0\n  μ = 1.0\n  σ(ε) = λ*tr(ε)*one(ε) + 2*μ*ε\n\n  degree = 2*order\n  Ω = Triangulation(model)\n  dΩ = Measure(Ω,degree)\n\n  a(u,v) = ∫(ε(v) ⊙ (σ∘ε(u)))*dΩ\n  l(v) = 0\n\n  op = AffineFEOperator(a,l,U,V)\n\n  options = \"-ksp_error_if_not_converged true -ksp_converged_reason\"\n  x = GridapPETSc.with(args=split(options)) do\n    solver = PETScElasticitySolver(U)\n    A, b = get_matrix(op), get_vector(op)\n    ns = numerical_setup(symbolic_setup(solver,A),A)\n    x = allocate_in_domain(A)\n    fill!(x,0.0)\n    solve!(x,ns,b)\n  end\n\n  uh = FEFunction(U,x)\nend","category":"page"},{"location":"Examples/Elasticity/","page":"-","title":"-","text":"","category":"page"},{"location":"Examples/Elasticity/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"NonlinearSolvers/#GridapSolvers.NonlinearSolvers","page":"NonlinearSolvers","title":"GridapSolvers.NonlinearSolvers","text":"","category":"section"},{"location":"NonlinearSolvers/#GridapSolvers.NonlinearSolvers.ContinuationFEOperator","page":"NonlinearSolvers","title":"GridapSolvers.NonlinearSolvers.ContinuationFEOperator","text":"struct ContinuationFEOperator <: FESpaces.FEOperator\n  op1    :: FEOperator\n  op2    :: FEOperator\n  switch :: ContinuationSwitch\n  reuse_caches :: Bool\nend\n\nFEOperator implementing the continuation method for nonlinear solvers. It switches between  its two operators when the switch is triggered.\n\nContinuation between more that two operators can be achieved by daisy-chaining two or more  ContinuationFEOperators.\n\nIf reuse_caches is true, the Jacobian of the first operator is reused for the second  operator. This is only possible if the sparsity pattern of the Jacobian does not change.\n\n\n\n\n\n","category":"type"},{"location":"NonlinearSolvers/#GridapSolvers.NonlinearSolvers.ContinuationFEOperator-Tuple{Gridap.FESpaces.FEOperator, Gridap.FESpaces.FEOperator, Int64}","page":"NonlinearSolvers","title":"GridapSolvers.NonlinearSolvers.ContinuationFEOperator","text":"ContinuationFEOperator(op1::FEOperator, op2::FEOperator, niter::Int; reuse_caches::Bool = true)\n\nContinuationFEOperator that switches between op1 and op2 after niter iterations.\n\n\n\n\n\n","category":"method"},{"location":"NonlinearSolvers/#GridapSolvers.NonlinearSolvers.ContinuationSwitch","page":"NonlinearSolvers","title":"GridapSolvers.NonlinearSolvers.ContinuationSwitch","text":"mutable struct ContinuationSwitch{A}\n  callback :: Function\n  caches   :: A\n  switched :: Bool\nend\n\nContinuationSwitch(callback::Function, caches)\n\nSwitch that implements the switching logic for a ContinuationFEOperator.\n\nThe callback function must provide the following signatures:\n\nReset: callback(u::FEFunction,::Nothing,cache) -> (switch::Bool, new_cache)\nUpdate: callback(u::FEFunction,b::AbstractVector,cache) -> (switch::Bool, new_cache)\n\nwhere u is the current solution (as a FEFunction) and b is the current residual. The first  signature is called by allocate_residual and is typically used to reset the switch for a new  nonlinear solve. The second signature is called by residual! and is used to update the switch based on the current residual.\n\nThe cache is (potentially) mutated between each call, and can hold any extra information  needed for the continuation logic.\n\n\n\n\n\n","category":"type"},{"location":"NonlinearSolvers/#GridapSolvers.NonlinearSolvers.ContinuationSwitch-Tuple{Int64}","page":"NonlinearSolvers","title":"GridapSolvers.NonlinearSolvers.ContinuationSwitch","text":"ContinuationSwitch(niter::Int)\n\nSwitch that will change operators after niter iterations.\n\n\n\n\n\n","category":"method"},{"location":"NonlinearSolvers/#GridapSolvers.NonlinearSolvers.NLsolveNonlinearSolver","page":"NonlinearSolvers","title":"GridapSolvers.NonlinearSolvers.NLsolveNonlinearSolver","text":"NLsolveNonlinearSolver <: NonlinearSolver\n\nNLsolveNonlinearSolver(ls::LinearSolver;kwargs...)\nNLsolveNonlinearSolver(;kwargs...)\n\nWrapper for NLsolve.jl nonlinear solvers. It is equivalent to the wrappers in Gridap, but  with support for nonlinear preconditioners. Same kwargs as in nlsolve. Due to NLSolve.jl not using LinearAlgebra's API, these solvers are not compatible with PartitionedArrays.jl. For parallel computations, use NewtonSolver instead.\n\n\n\n\n\n","category":"type"},{"location":"NonlinearSolvers/#GridapSolvers.NonlinearSolvers.NewtonSolver","page":"NonlinearSolvers","title":"GridapSolvers.NonlinearSolvers.NewtonSolver","text":"struct NewtonSolver <: Algebra.NonlinearSolver\n\nNewton-Raphson solver. Same as NewtonRaphsonSolver in Gridap, but with a couple addons: \n\nBetter logging and verbosity control.\nBetter convergence criteria. \nWorks with geometric LinearSolvers/Preconditioners. \n\n\n\n\n\n","category":"type"},{"location":"#GridapSolvers","page":"Home","title":"GridapSolvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GridapSolvers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GridapSolvers provides algebraic and non-algebraic solvers for the Gridap ecosystem, designed with High Performance Computing (HPC) in mind.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solvers follow a modular design, where most blocks can be combined to produce PDE-taylored solvers for a wide range of problems.","category":"page"},{"location":"#Table-of-contents","page":"Home","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"SolverInterfaces.md\",\n  \"MultilevelTools.md\",\n  \"LinearSolvers.md\",\n  \"NonlinearSolvers.md\",\n  \"BlockSolvers.md\",\n  \"PatchBasedSmoothers.md\",\n]","category":"page"},{"location":"#Extensions","page":"Home","title":"Extensions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"Extensions/GridapP4est.md\",\n  \"Extensions/GridapPETSc.md\",\n  \"Extensions/IterativeSolvers.md\",\n  \"Extensions/Pardiso.md\",\n]","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"Examples/Stokes.md\",\n  \"Examples/NavierStokes.md\",\n  \"Examples/StokesGMG.md\",\n  \"Examples/NavierStokesGMG.md\",\n  \"Examples/DarcyGMG.md\",\n]","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GridapSolvers is a registered package in the official Julia package registry.  Thus, the installation of GridapSolvers is straight forward using the Julia's package manager. Open the Julia REPL, type ] to enter package mode, and install as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add GridapSolvers\npkg> build","category":"page"},{"location":"","page":"Home","title":"Home","text":"If using the extensions for GridapP4est.jl or GridapPETSc.jl, building is required to link the external artifacts (e.g., PETSc, p4est) to the Julia environment. Restarting Julia is required after building in order to make the changes take effect.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default, Julia will configure GridapSolvers to work using Julia's pre-compiled artifacts for MPI, PETSc and p4est. However, you can also link local copies of these libraries. This might be very desirable in clusters, where hardware-specific libraries might be faster/more stable than the ones provided by Julia. To do so, follow the next steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"MPI.jl\nGridapPETSc.jl\nGridapP4est.jl, and P4est_wrapper.jl","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In order to give credit to the GridapSolvers contributors, we simply ask you to cite the Gridap main project as indicated here and the sub-packages you use as indicated in the corresponding repositories. Please, use the reference below in any publication in which you have made use of GridapSolvers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Manyer2024, \n  doi = {10.21105/joss.07162}, \n  url = {https://doi.org/10.21105/joss.07162}, \n  year = {2024}, \n  publisher = {The Open Journal}, \n  volume = {9}, \n  number = {102}, \n  pages = {7162}, \n  author = {Jordi Manyer and Alberto F. Martín and Santiago Badia}, \n  title = {GridapSolvers.jl: Scalable multiphysics finite element solvers in Julia}, \n  journal = {Journal of Open Source Software} \n} ","category":"page"}]
}
